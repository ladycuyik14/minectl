#! /bin/bash
#
#	minelib - Library for functions frequently used by minectl's scripts
#
#	Version 1.0
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.

###########################
# Miscellaneous functions #
###########################

# Inform user about operations being executed
tell() {
        echo -en "$@"
}

# Echo state and indicate success
succ() {
        if [ -z "$1" ]; then
                echo -e "[   done    ]"
        else
                echo -e "$1"
        fi
        return 0
}

# Echo state and indicate an error
err() {
        if [ -z "$1" ]; then
                echo -e "[   error   ]" 1>&2
        else
                echo -e "$1" 1>&2
        fi
        return 1
}

# Print out an error message to stderr
error() {
	echo -e "ERROR: $@" 1>&2
	return 1
}

# Echo state and indicate faliure and exit
fail() {
        if [ -z "$1" ]; then
                echo -e "[  failed   ]" 1>&2
        else
                echo -e "$1" 1>&2
        fi
        exit 1
}

# List (just) directories in the current folder (without sub directories)
ls_dir() {
	local DIR="$1"

	if [ -z "$DIR" ]; then
		DIR="./"
	fi

	find "$DIR" -type d 2> /dev/null | grep -E ^"./.[^/]*"$ | sed 's:./::g'
}

# Operate on files
fileop() {
	local GREP="grep"
	local IGNORE_CASE=false
	local BEGINS_WITH=false
	local ENDS_WITH=false
	local FILE=""
	local MATCH=""

	# Add a string to a file
	fileop_add() {
		echo "$MATCH" >> "$FILE"
		return $?
	}

	# Check if a certain string is contained in a file
	fileop_contains() {
		if ( $IGNORE_CASE ); then
			GREP="$GREP -i"
		fi

		if ( $BEGINS_WITH && $ENDS_WITH ); then
			$GREP -E "^$PATTERN[[:blank:]]*$" "$FILE" 2> /dev/null
		elif ( $BEGINS_WITH ); then
			$GREP ^"$PATTERN" "$FILE" 2> /dev/null
		elif ( $ENDS_WITH ); then
			$GREP -E "$PATTERN[[:blank:]]*$" "$FILE" 2> /dev/null
		else
			$GREP "$PATTERN" "$FILE" 2> /dev/null
		fi

		return $?
	}

	# Remove a string that is in the beginning of a file from this file
	fileop_remove() {
		while read MATCH; do		
			sed -i "/$MATCH/d" "$FILE" 2> /dev/null
		done < "$1"
	
		rm -f "$1" 2> /dev/null
	}

	while (( $# ));do
		echo "$1" >> /tmp/test0
		case $1 in
			--ignore-case|-i)	IGNORE_CASE=true
			;;
			--full-match|-f)	BEGINS_WITH=true
						ENDS_WITH=true
			;;
			--begins-with|-b)	BEGINS_WITH=true
			;;
			--ends-with|-e)		ENDS_WITH=true
			;;
			*)			break
		esac
		shift
	done

	if ( $IGNORE_CASE ); then
		GREP="$GREP -i"
	fi

	local CMD="$1"
	local PATTERN="$2"
	local FILE="$3"

	case $1 in
		contains)	fileop_contains
		;;
		remove)		local TMP_FILE="`mktemp`"
				fileop_contains > "$TMP_FILE"
				fileop_remove "$TMP_FILE"
				rm -f "$TMP_FILE" 2> /dev/null
		;;
		add)		fileop_add
		;;
		*)		error "Unknown file operation \"CMD\""
	esac
}

# Extract data from a file removing comments and empty lines
extract_data() {
	grep -vE "^[[:blank:]]*$|^[[:blank:]]*#" $1 2> /dev/null
}

# Ask a question and return 0 on 'yes' or 1 otherwise
ask() {
	USAGE="\
	Usage: ask [The yes / no question]\nReturns 0 on \"y\" or 1 on \"n\" where \"n\" is default."

	if [ $# -lt 1 ]; then
		echo -e $USAGE
		return 2
	fi

	echo -n "$@ [y/N]: " 
	read ANSWER
	shopt -s nocasematch
	case "$ANSWER" in
		j|y|ja|yes)
			return 0;;
		*)	return 1;;
	esac
	shopt -u nocasematch
}

# Change the value of an existing variable inside a file
set_var() {
	local DECLARE_ARGS=

	echo "$@"

	case $1 in
		-u|-l)	DECLARE_ARGS="$1"
		shift
	esac
	
	local VAR_DEC="$1"
	local FILE="$2"

	local VARIABLE_PURE="`echo "$VAR_DEC" | cut -d "=" -f 1`"
	local $DECLARE_ARGS VARIABLE="$VARIABLE_PURE"
	local VALUE="`echo "$VAR_DEC" | cut -d "=" -f 2`"
	local OVERHEAD="`echo "$VAR_DEC" | cut -d "=" -f 3-`"

	# Check if variable is not empty
	if [ -n "$VARIABLE_PURE" ]; then
		# If the variable name preceeds a "-", that means
		# we want the variable removed from the file
		if [ -n "`echo "$VARIABLE_PURE" | grep ^"-" 2> /dev/null`" ]; then
			VARIABLE_PURE="`echo "$VARIABLE_PURE" | cut -d "-" -f 2`"
			sed -i "/^$VARIABLE_PURE=/d" "$FILE" 2> /dev/null
		else
			# Search for variable inside the file	
			local VAR_LINE="`grep ^"$VARIABLE=" "$FILE" 2> /dev/null`"

			# If the variable is in the file, replace it with its new value
			if ( fileop contains -b "$VARIABLE=" "$FILE" > /dev/null ); then
				sed -i "s/$VAR_LINE/$VARIABLE=$VALUE/" "$FILE" 2> /dev/null
			else
				fileop add "$VARIABLE=$VALUE" "$FILE"
			fi

			echo "$VARIABLE=$VALUE"
		fi
	else
		error "No variable specified"
		return 2
	fi

	# Check if we had invalid overhead
	if [ -n "$OVERHEAD" ]; then
		err "Ignoring invalid overhead '$OVERHEAD'"
		return 1
	fi
	
	return 0
}

# Check, whether we are a certain user
is_user() {
	local TARGET_USER="$1"

	if [ "$USER" == "$TARGET_USER" -o "$EUID" == "$TARGET_USER" ]; then
		return 0
	fi
	
	return 1
}

# Print out a file and highlight changes. Usage:
# print_file [--offset, -o <offset>] <file_name> [change_log]
print_file() {
	local OFFSET=""

	# Check if we specified an offset
	case $1 in
		--offset|-o)	OFFSET="$2"
				shift 2
	esac

	local FILE="$1"
	local CHANGE_LOG="$2"

        while read LINE; do
		local CONTINUE=false

		if [ -f "$CHANGE_LOG" ]; then
			while read CHANGE; do
				if [ "$CHANGE" == "$LINE" ]; then
					echo -e "$OFFSET\033[1m$LINE\033[0m"
					CONTINUE=true
					continue
				fi
			done < "$CHANGE_LOG"
		fi

		# Skip the output of the line if
		# it has already been highlighted
		$CONTINUE && continue

		echo -e "$OFFSET$LINE"
        done < $FILE
}

# Access a server's directory securely
# XXX: Do not just use a simple "cd" statement to change to a server's directory, beacuase
# if a user does not specify a server name by mistake, we will change to $MC_HOME/servers 
# and, if clean is called "clean()", may remove all servers by mistake. That won't be good!
# 'access_server' also makes sure that a certain server (directory) exists
access_server() {
	# First parameter is the server name
	# XXX: This variable needs to be global!
	SERVER_NAME=$1
	
	# Check is server name is not empty
	test -n "$SERVER_NAME" 2> /dev/null || fail "No server name specified."

	# Check whether server's directory is accessible
	test -d "$SERVERS_DIR/$SERVER_NAME" 2> /dev/null || fail "Server '$SERVER_NAME' does not exist"

	# Check whether server's directory is accessible
	cd "$SERVERS_DIR/$SERVER_NAME" 2> /dev/null || fail "Cannot access_server server's directory"

	# Check if we did really change to a subfolder of $MC_HOME/servers
	test "`dirname $PWD`" == "$SERVERS_DIR" 2> /dev/null || fail "We are somehow in the '$SERVERS_DIR' directory"
}

# Create named pipes
mk_fifos() {
        for FIFO in stdin stdout stderr; do
                if [ -e $FIFO ]; then
                        if [ ! -p $FIFO ]; then
                                fail "File $FIFO is blocking eponymous pipe"
                        fi
                else
                        mkfifo $FIFO
                fi
        done
}
 
###################################
# Import error codes and messages #
###################################
# TODO: Implement later
#. `dirname $0`/errcodes || err "Error codes could not be loaded from `dirname $0`/errcodes"
