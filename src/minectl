#! /bin/bash
#
#	minectl - Control a minecraft server
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

#######################
# Version information #
#######################

VERSION=5.6
ARCH=noarch

####################
# Global variables #
####################

# Define default minectl user
MC_USER=minectl

# Define home directory
MC_HOME="/home/$MC_USER"

# Binaries' directory
BIN_DIR="/usr/local/bin"

# Library directory
LIB_DIR="/usr/local/libexec/minectl"

# Servers directory
SERVERS_DIR="$MC_HOME/servers"

# JARs' directory
JAR_DIR="$LIB_DIR/jar"

# JARs' repository
JAR_REPO="$LIB_DIR/jar-repo"

# Define temporary directory
TMP_DIR="`mktemp -d`"

# Define our configuration file name
SERVER_CONFIG="./.mcsrv.cfg"

# The server's properties file
SERVER_PROPERTIES="./server.properties"

# The server's white-list
WHITE_LIST="./white-list.txt"

# The server's ops-list
OP_LIST="./ops.txt"

# Define shared library
MC_LIB="$LIB_DIR/minelib"

# Synopsis of usage for user information
USAGE="Usage:	\033[1m`basename $0`\033[0m [\033[1mINDEPENDENT_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m \033[3mSERVER_NAME\033[0m [\033[1mSERVER_SPECIFIC_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m [\033[1mMETA_COMMAND\033[0m]

\033[1mINDEPENDENT COMMANDS\033[0m
	\033[1minit\033[0m
		Initialize the server manager.

	\033[1mlist\033[0m [\033[1m--verbose\033[0m, \033[1m--very-verbose\033[0m]
		List available servers.

	\033[1madd\033[0m \033[3mserver_name\033[0m [\033[1m--jar\033[0m \033[3mjar_file\033[0m]
		Add a new server. 
		You can specify a jar file to be used or select it interactively.

	\033[1mjar\033[0m [\033[1mREPO_COMMAND\033[0m]
		Manage the JAR files and repository.
		See \033[1m`basename $0` jar --help\033[0m for further information.

\033[1mSERVER SPECIFIC COMMANDS\033[0m
	\033[1mremove\033[0m [\033[1m--force\033[0m]
		Entirely remove a server from the disk.
		You can avoid querying by using the \033[1m--force\033[0m switch.

	\033[1m\033[3mServer configuration\033[0m
		\033[1mpasswd\033[0m [\033[1mPASSWD_COMMAND\033[0m \033[3muser_name\033[0m]
			Manage the server's users.
			See \033[1m`basename $0` --help passwd\033[0m for further information.

		\033[1mconfigure\033[0m, \033[1mconfig\033[0m or \033[1mcfg\033[0m
			Show the server's meta-configuration.
		\033[1mconfigure\033[0m [\033[3mvariable\033[0m=\033[4mvalue\033[0m]
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's meta-configuration file.
		\033[1mconfigure\033[0m [-\033[3mvariable\033[0m]
			Delete \033[3mvariable\033[0m from the server's meta-configuration file.

		\033[1mproperties\033[0m, \033[1mprops\033[0m or \033[1mpro\033[0m
			Show the appropriate server.properties data.
		\033[1mproperties\033[0m [\033[3mvariable\033[0m=\033[4mvalue\033[0m]
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's server.properties file.
		\033[1mproperties\033[0m [-\033[3mvariable\033[0m]
			Delete \033[3mvariable\033[0m from the server's server.properties file.

		\033[1mset-jar\033[0m \033[3mJAR_file\033[0m
			Set \033[3mJAR_file\033[0m as the active JAR file for the server.

	\033[1m\033[3mBackup, Restore and Reset\033[0m
		For \033[1mbackup\033[0m, \033[1mrestore\033[0m and \033[1mreset\033[0m you can use the
			following common options:
			\033[1m--force\033[0m
				To activate non-interactive mode in operations.
			\033[1m--grace-time\033[0m \033[3mgrace_time\033[0m
				To set the grace time in seconds for when the 
				appropriate server will be shut down (default: 10).
			\033[1m--message\033[0m \033[3mmessage\033[0m
				To specify the message send to users on the server.

		\033[1mbackup\033[0m [\033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Create a backup of the server.
			You can specify the name of the backup to be saved.

		\033[1mrestore\033[0m [\033[1m--clean\033[0m, \033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Restore latest backup of the server.
			You can specify the name of the backup to be restored in \033[3mbackup_name\033[0m 
			instead of restoring the latest one.
			To erase the server's data before restoring (to clean it up) use the 
			\033[1m--clean\033[0m switch, which must be the first argument.

		\033[1mreset\033[0m [\033[1m--erase-config\033[0m, \033[1mCOMMON_OPTIONS\033[0m]\033[0m
			Reset the server to its initial state.
			Use the \033[1m--erase-config\033[0m switch to also erase the server's configuration.

	\033[1m\033[3mInit / Systemd service control\033[0m
		\033[1mstatus\033[0m
		        Check if the server is running

	\033[1m\033[3mJava program commands\033[0m
		\033[1mexec\033[0m [\033[1mARGS\033[0m] \033[3mMINECRAFT_SERVER_COMMAND\033[0m
			Send commands to the server's stdin and print out replies
			Possible arguments are:
			\033[1m--verbose\033[0m, \033[1m-v\033[0m
				Show verbose output.
			\033[1m--show-tail\033[0m, \033[1m-s\033[0m
				Show the tail of the pipe and
				not only the command's results.
			\033[1m--wait-time\033[0m, \033[1m-w\033[0m \033[3mseconds\033[0m
				Specify waiting time in seconds
				to wait for the pipe to close again.

		\033[1mplayers\033[0m
		        List players logged in to the server
	
		\033[1mplayer-count\033[0m
		        List count of players logged in to the server.

		\033[3mMINECRAFT_JAVA_COMMAND\033[0m [\033[3mARGS\033[0m]
		        If none of the aforementioned commands apply, minectl will
		        interpret the command as command for the Java program.

\033[1mMETA COMMANDS\033[0m
	\033[1m--help\033[0m
		Print this infomation

	\033[1m--version\033[0m     		
		Print version information and exit
"

######################################################################################################################

###########################
# Miscellaneous functions #
###########################

# Clean up the server directory
clean() {
	# First parameter is the server name
	SERVER_NAME=$1
	shift

	# Change to server's directory
	access_server "$SERVER_NAME" || fail # XXX: Just to be sure!

	# Remove server directory's content
	rm -R * > /dev/null 2> /dev/null || fail "Server \"$SERVER_NAME\" could not be cleaned up"
}

# Indicate failure when loading of shared library fails
lib_fail() {
	echo "Could not load shared library: $MC_LIB" 1>&2
	exit 1
}

#########################
# Source shared library #
#########################
. $MC_LIB 2> /dev/null || lib_fail

######################################################################################################################

##################
# Main functions #
##################

# Initialize the minecraft server installation and configuration after installation
# This should be done interactively
init() {
	# Change to home directory
	cd $MC_HOME 2> /dev/null || fail "Cannot change to home directory"

	# Check if no servers are configured yet
	if ( ! list ); then
		echo -en "What name shall your first server have?\nServer name: "
		read SERVER_NAME

		# Check if we already have some JAR files at hand (although this should not be the case)
		if ( jar list ); then
			# Ask the user which jar file shall be used
			echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
			read JAR_FILE
		else
			# Ask the user to update the system
			if ( ask "Do you want to run an update now?" ); then
				jar upgrade
				jar list
				echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
				read JAR_FILE
			else
				echo "Please run an update manually and try again."
				exit 1
			fi
		fi

		# Add the new server
		add "$SERVER_NAME" --jar "$JAR_FILE" 

	# If we already have servers, don't initialize
	else
		succ "There are already servers.\nNo initialization required."
	fi		
}

# Add a server
add() {
	# First parameter is the server name
	local SERVER_NAME=$1
	shift

	# JAR file to be used
	local JAR_FILE=

	# Switch options
	while (( $# )); do
		case $1 in
			--jar)	JAR_FILE=$2
				shift
			;;
			*)	error "Unknown parameter '$1'"
		esac
		shift
	done

	# Change to servers directory
	cd $SERVERS_DIR 2> /dev/null || fail "Could not change to server directory"

	# Check if we specified a server name
	if [ -n "$SERVER_NAME" ]; then
		# Check whether no such file or folder already exists
		if [ -e "$SERVER_NAME" ]; then
			# If there's already such a directory, we assume that the server already exists
			if [ -d "$SERVER_NAME" ]; then
				succ "Server $SERVER_NAME already exists"
				exit 0
			# If the thing with the server's name is not a directory, we give up :-(
			else
				fail "A file named $SERVER_NAME already exists\nPlease remove it."
			fi				
		else
			# Create the server
			mkdir "$SERVER_NAME" 2> /dev/null || fail "Could not create server's directory"
			cp "$SERVER_CONFIG" "$SERVER_NAME" 2> /dev/null || fail "Could not copy skeleton server configuration"

			# Change to new server
			access_server "$SERVER_NAME"

			# If JAR file was not specified, let the user select one iteractively
			if [ -z "$JAR_FILE" ]; then
				if ( jar list ); then
					echo -en "Please specify the jar file that you want to use.\nJAR file: "
					read JAR_FILE
				# ...and exit if we don't have any
				else
					exit 1
				fi
			fi

			configure "JAR_FILE=$JAR_FILE"

			# Create basic minecraft-specific files
			touch server.properties ops.txt white-list.txt 2> /dev/null || err "Could not create basic config files"

			# Create named pipes for the server
			mk_fifos
		fi
	# If no name was specified, we cannot create a server
	else
		fail "No server name specified"
	fi		
}

# Remove a server
remove() {
	# As default, ask again, before removing the server
	local FORCE=false

	# Switch options
	while (( $# ));do
		case $1 in
			--force)	FORCE=true
			;;
			*)		error "Unknown parameter '$1'"
		esac
		shift
	done

	# Do we really want to remove the server?
	local REMOVE=false

	# Check if we want to remove non-interactively
	if ( $FORCE ); then
		REMOVE=true
	else
		# Ask the user if they really wants to remove the server
		ask "Do you really want to remove the server '$SERVER_NAME'?" && REMOVE=true
	fi

	# If we finally want to remove the server
	if ( $REMOVE ); then
		# Change to server's directory
		access_server "$SERVER_NAME"

		# Stop server if it is running
		srv_status > /dev/null 2> /dev/null && fail "Server is still running"

		# Change to parent folder
		cd .. 2> /dev/null || fail "Cannot change to parent directory"

		# Remove stuff
		rm -R "$SERVER_NAME" && succ "Server \"$SERVER_NAME\" removed" || fail "Failed to remove server\"$SERVER_NAME\""
	fi
}

# List available servers
list() {
	# Define tamporary server list	
	local SERVER_LIST="`mktemp`"
	local RETVAL=1

	# Don't be verbose by default
	local VERBOSE=false
	local VERY_VERBOSE=false

	# List all folders (servers) in the servers directory
	cd "$SERVERS_DIR" 2> /dev/null && ls_dir 2> /dev/null > "$SERVER_LIST"

	# Switch options
	while (( $# ));do
		case $1 in
			--verbose|-v)		VERBOSE=true
			;;
			--very-verbose|-vv)	VERBOSE=true
						VERY_VERBOSE=true
			;;
			*)			error "Unknown parameter '$1'"
		esac
		shift
	done

	# Iterate over all servers in the list
	while read SERVER_NAME; do
		# We obviously do have servers
		RETVAL=0

		# Print the server's name
		# Bold if verbose
		$VERBOSE && echo -en "\033[1m"
		echo -en "$SERVER_NAME"
		$VERBOSE && echo -e "\033[0m" || echo ""

		# Print some more information in verbose mode
		if ( $VERBOSE ); then
			access_server "$SERVER_NAME"
			echo -e " \033[1mCONFIGURATION:\033[0m"
			configure
			if ( $VERY_VERBOSE ); then
				echo -e " \033[1mPROPERTIES:\033[0m"
				properties
			fi
		fi
	done < "$SERVER_LIST"

	return $RETVAL
}

# Configure minecraft server installation and configuration
configure() {
	print_configuration() {		
		# Set temporary configuration file
		local TMP_SERVER_CONFIG="`mktemp`"

		# Delete comments and empty lines from config file
		extract_data $SERVER_CONFIG > $TMP_SERVER_CONFIG 2> /dev/null

		# Print used JAR file
		if ( fileop -b contains "JAR_FILE=" "$1" > /dev/null 2> /dev/null); then
			echo -en "\033[1m"
		fi
		echo -e " JAR_FILE=`readlink minecraft_server.jar 2> /dev/null`\033[0m"

		# Print configuration file content
                print_file -o " " "$TMP_SERVER_CONFIG" "$1"

		# Remove temp file
		rm -f $TMP_SERVER_CONFIG 2> /dev/null
	}
	
	# Set a new active JAR file
	set_jar() {
		# The second parameter is the JAR file
		local JAR_FILE_NAME=$1
		local JAR_FILE=""

		# Read JAR file interactively if not specified via a parameter
		if [ -z "$JAR_FILE_NAME" ]; then
			fail "No JAR file specified"
		fi

		# Check if JAR file is present
		if [ -f $JAR_FILE_NAME ]; then
			JAR_FILE=$JAR_FILE_NAME
		elif [ -f $JAR_DIR/$JAR_FILE_NAME ]; then
			JAR_FILE=$JAR_DIR/$JAR_FILE_NAME
		elif [ -f $JAR_DIR/$JAR_FILE_NAME.jar ]; then
			JAR_FILE=$JAR_DIR/$JAR_FILE_NAME.jar
		else
			fail "Specified JAR file could not be found"		
		fi

		# Link to new JAR file
		unlink minecraft_server.jar 2> /dev/null; ln -sf $JAR_FILE minecraft_server.jar 2> /dev/null &&	echo "Server should be restarted" || fail "Could not set new JAR file"
	}

	# Print configuration of server, if no arguments are specified
	if [ $# -eq 0 ]; then
		print_configuration
	else
		local ALTERED_VARS="`mktemp`"

		while (( $# )); do
			local VARIABLE="$1"
			shift

			local -u VAR_NAME="`echo "$VARIABLE" | cut -d "=" -f 1`"
			local VAR_VAL="`echo "$VARIABLE" | cut -d "=" -f 2-`"

			# Check if we want to change the JAR file
			if [ "$VAR_NAME" == "JAR_FILE" ]; then
				set_jar "$VAR_VAL"
				echo "JAR_FILE=$VAR_VAL" >> "$ALTERED_VARS"
			else
				# Change variable
				set_var -u "$VARIABLE" "$SERVER_CONFIG" >> "$ALTERED_VARS"
			fi
		done

		# Print new configuration after modifications
		print_configuration "$ALTERED_VARS"

		rm -f "$ALTERED_VARS" 2> /dev/null
	fi
}

# Configure a server's properties
properties() {
	print_properties() {		
		# Set temporary properties file
		local TMP_SERVER_PROPERTIES="`mktemp`"

		# Delete comments and empty lines from config file
		extract_data $SERVER_PROPERTIES > $TMP_SERVER_PROPERTIES 2> /dev/null

		# Print properties file content
                print_file -o " " "$TMP_SERVER_PROPERTIES" "$1"

		# Remove temp file
		rm -f $TMP_SERVER_PROPERTIES 2> /dev/null
	}

	if [ $# -eq 0 ]; then
		print_properties
	else
		local ALTERED_VARS="`mktemp`"

		while (( $# )); do
			local VARIABLE="$1"
			shift

			# Change variable and			
			# mark it as altered
			set_var -l "$VARIABLE" "$SERVER_PROPERTIES" >> "$ALTERED_VARS"
		done

		# Print new properties after modifications
		print_properties "$ALTERED_VARS"
		rm -f "$ALTERED_VARS" 2> /dev/null
	fi
}
	
# Manage a server's users
passwd() {
	#################
	# Set variables #
	#################

	# Set temporary file
	local TMP="`mktemp`"

	# Usage information
	local USAGE="Usage: \033[1m`basename $0`\033[0m \033[3mserver_name\033[0m \033[1mpasswd\033[0m [\033[3mCOMMAND\033[0m \033[4muser_name\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1madd\033[0m, \033[1mwhitelist\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the white-list

	\033[1mremove\033[0m, \033[1mblacklist\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from white-list

	\033[1mop\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the ops list

	\033[1mdeop\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from the ops list

	\033[1mstatus\033[0m \033[3muser_name\033[0m
		List status of \033[3muser_name\033[0m

	\033[1mprint\033[0m, \033[1mlist\033[0m
		Print current status, white- and ops-list

	\033[1mlock\033[0m
		Lock server by putting it into online mode and enabling the white-list (recommended)

	\033[1munlock\033[0m
		Unlock server by putting it into offline mode an disabling the white-list (not recommended)

	\033[1mhelp\033[0m
		Print this information
"

	####################
	# Passwd functions #
	####################

	# Reload the whitelist
	whitelist_reload() {
		srv_exec whitelist reload > /dev/null 2> /dev/null
	}

	# Check if we are given a valid user name
	valid_user() {
		# Fail if no user name has been given
		if [ -z "$1" ]; then
			fail "No user name given"
		fi
	}

	# Check whether a certain user is white-listed
	is_whitelisted() {
		valid_user "$1"
		if ( fileop -f -i contains "$1" "$WHITE_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1mwhitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		fi
	}

	# Check whether a certain user is an operator
	is_op() {
		valid_user "$1"
		if ( fileop -f -i contains "$1" "$OP_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1man operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Add a user to the white-list, iff he's not in it yet
	whitelist() {
		valid_user "$1"
		if ( ! is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( fileop add "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed whitelisting $1\033[0m on server \033[1m$SERVER_NAME\033[0m'.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1malready\033[0m whitelisted on server \033[1m$SERVER_NAME\033[0m."
		fi
		
		whitelist_reload
	}

	# Remove user from the white list, iff he's in it
	remove() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			deop "$1" 2> /dev/null
			if ( fileop -f -i remove "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 removed\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed removing $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi

		whitelist_reload
	}

	# Add a user to the operators list
	op() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( ! is_op "$1" > /dev/null 2> /dev/null ); then		
				if ( fileop add "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
					# Make the user an operator instantly 
					# on the running server
					srv_exec op "$1" > /dev/null 2> /dev/null

					succ "User \033[1m$1\033[0m is \033[1mnow an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
				else
					err "\033[1mFailed opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
				fi
			else
				err "User \033[1m$1\033[0m is \033[1malready an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Delete a user from the operators list
	deop() {
		valid_user "$1"
		if ( is_op "$1" > /dev/null 2> /dev/null ); then
			if ( fileop -f -i remove "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
				# Deop the user on running server
				srv_exec deop "$1" > /dev/null 2> /dev/null

				succ "User \033[1m$1\033[0m is \033[1mno longer an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed de-opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Print the status of a user
	status() {
		valid_user "$1"
		if ( is_whitelisted "$1" ); then	
			is_op "$1"
		fi
	}

	# Print the status of the whole server mode, white-list and ops-list configuration
	print() {
		# Determine mode
		echo -en "Server \033[1m$SERVER_NAME\033[0m is configured as "
		if ( fileop -f -i contains "online-mode=true" "$SERVER_PROPERTIES" > /dev/null 2> /dev/null ); then
			echo -en "\033[1monline\033[0m"
		else
			echo -en "\033[1moffline\033[0m"
		fi

		# Determine whether white-list is enabled
		echo -n ", its white-list is "
		if ( fileop -f -i contains "white-list=true" "$SERVER_PROPERTIES" > /dev/null 2> /dev/null ); then
			echo -e "\033[1menabled\033[0m."
		else
			echo -e "\033[1mdisabled\033[0m."
		fi	

		# Display users
		echo -e "\n\033[1mWhitelisted users:\033[0m"
		cat "$WHITE_LIST" 2> /dev/null
		echo -e "\n\033[1mOperators:\033[0m"
		cat "$OP_LIST" 2> /dev/null
		echo ""
	}

	# Lock the server by putting it into online mode and enabling the white-list
	lock() {
		properties "online-mode=true" "white-list=true" > /dev/null && succ "Server locked." || fail "Server locking failed."
	}

	# Unlock the server by putting it into offline mode and disabling the white-list
	# XXX: This is not recommended. We anyway want to offer this feature for there 
	# might be user that want to run an open game server e.g. on networking parties
	unlock() {
		properties "online-mode=false" "white-list=false" > /dev/null && succ "Server unlocked." || fail "Server unlocking failed." 
	}

	# Switch commands
	while (( $# )); do
		case "$1" in
			reload)			whitelist_reload
			;;
			add|whitelist)		whitelist $2
						shift
			;;
			remove|blacklist)	remove $2
						shift
			;;
			op)			op $2
						shift
			;;
			deop)			deop $2
						shift
			;;
			status)			status $2
						shift
			;;
			lock)			lock
			;;
			unlock)			unlock
			;;
			""|list|print)		print
			;;
			-h|--help|help)		echo -e "$USAGE" | /usr/bin/less -r
						exit 0
			;;
			*)			fail "Unknown argument '$1'. Try:\n\t\$ $0 $CMD --help"
		esac
		shift
	done
}

# Create a backup of the server
backup() {
	# Set current time and date as default backup name
	local BACKUP_NAME="$SERVER_NAME-`date +%Y.%m.%d-%H.%M`"
	
	if [ $# -gt 0 ]; then
		BACKUP_NAME="$@"
	fi
	
	# Create the backup as a gzip compressed tar archive, but with the custom *.mcb suffix 
	tar czf "$MC_HOME/backup/$BACKUP_NAME.mcb" * > /dev/null 2> /dev/null 
	if [ $? -le 1 ]; then
		return 0
	else
		fail "Could not create backup"
	fi
}

# Restore the server
restore() {
	# Assume latest backup shall be restored
	local BACKUP_NAME="`ls -tl $MC_HOME/backup/$SERVER_NAME-* 2> /dev/null | head -n1 | awk '{print $9}'`"
	local BACKUP=""

	# We don't want to clean the server directory by default
	local CLEAN=false
	
	# Switch options
	while (( $# )); do
		case $1 in
			--clean|-c)		CLEAN=true
			;;
			*)			BACKUP_NAME="$@"
						break
		esac
     		shift
	done

	# Check whether the backup file is present...
	# ... as the file itself (full or relative file path)...
	if [ -f "$BACKUP_NAME" ]; then
		BACKUP="$BACKUP_NAME"
	# ... or as the file's name located in the backup folder ...
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME"
	# ... or finally as the file's name in the backup folder without the suffix specified.
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME.mcb" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME.mcb"
	# Fail otherwise
	else
		fail "Specified backup file could not be found"
	fi

	# Check if server is still running
	srv_status > /dev/null 2> /dev/null && fail "Server is still running"
			
	# Clean the server if wanted
	if ( $CLEAN ); then
		clean "$SERVER_NAME"
	fi

	# Perform restore
	tar xzf "$BACKUP" > /dev/null 2> /dev/null && return 0 || fail "Could not restore backup"
}

# Reset the server
reset() {
	# As default we want to keep our configuration
	local KEEP_CONFIG=false
	local CFG_BACKUP="`mktemp`"
	local FORCE=false
	local GRACE_TIME=10
	local MESSAGE="Server is being shut down for reset"

	# Switch options
	while (( $# )); do
		case $1 in
			--erase-config|-ec|-e)	KEEP_CONFIG=false
			;;
			--force|-f)		FORCE=true
			;;
			--grace-time|-t)	GRACE_TIME=$2
						shift
			;;
			--message|-m)		MESSAGE=$2
						shift
			;;
			*)			error "Unrecognized argument '$1'"
		esac
		shift
	done

	# Check if server is still running
	srv_status > /dev/null 2> /dev/null && fail "Server is still running"

	# If we want to keep the configuration, we create a temporal archive from them
	# XXX: Do not mix this up with our server's main backup() function
	if ( $KEEP_CONFIG ); then
		tar czf $CFG_BACKUP banned-ips.txt banned-players.txt ops.txt server.properties white-list.txt 2> /dev/null || fail "Saving of configuration failed"
	fi

	# Remember used jar file
	local JAR_FILE=`readlink minecraft_server.jar`
	
	# Clean up the server
	clean "$SERVER_NAME" || fail

	# Link back to the active minecraft_server.jar
	ln -s $JAR_FILE minecraft_server.jar || err "Resetting JAR file failed"
	
	# If we wanted to keep our configuration, we now restore its backup	
	if ( $KEEP_CONFIG ); then
		tell "Restoring configuration\t\t\t"
		tar xzf $CFG_BACKUP 2> /dev/null || fail "Could not restore configuration"
		rm $CFG_BACKUP 2> /dev/null
	fi
}

# Manage the JAR files
jar() {
	# Define repository list
	local REPO_LIST="$LIB_DIR/.repolist"

	# Set temporary repository for re-formatted repo list
	local TMP_REPO_LIST="`mktemp`"

	# Usage information
	local USAGE="Usage: \033[1m`basename $0`\033[0m \033[1mjar\033[0m [\033[3mCOMMAND\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m or \033[1mls\033[0m [\033[1m--all\033[0m]
		List available JAR files
 
	\033[1mupdate\033[0m
		Update JAR file repository
 
	\033[1mupgrade\033[0m
		Upgrade used JAR files to the latest ones

	\033[1mrepository\033[0m or \033[1mrepo\033[0m
		Perform operations on the repositories
		See \033[1m`basename $0` jar repository --help\033[0m for further information.

	\033[1m--help\033[0m, \033[1m-h\033[0m or \033[1mhelp\033[0m
		Print this information
"
	
	##################
	# Repo functions #
	##################

	# Parse the repository list
	parse_repository() {
		# Check whether the repository list exists
		test -f "$REPO_LIST" 2> /dev/null || fail "Checking for repository list failed"

		# Re-format repo file
		extract_data "$REPO_LIST" > "$TMP_REPO_LIST" 2> /dev/null || fail "Parsing repository file failed"
	}

	# Operate on the repository
	repository() {
		# Usage information
		local USAGE="Usage: \033[1m`basename $0`\033[0m \033[1mjar\033[0m \033[1mrepository\033[0m [\033[3mCOMMAND\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m or \033[1mls\033[0m [\033[1m--verbose\033[0m]
		List active repositories

	\033[1madd\033[0m \033[3mURL\033[0m \033[3mname\033[0m
		Add a repository

	\033[1mremove\033[0m, \033[1mrm\033[0m or \033[1mdelete\033[0m \033[3mname\033[0m
		Remove a repository

	\033[1m--help\033[0m, \033[1m-h\033[0m or \033[1mhelp\033[0m
		Print this information
"
		# List available repositories
		list_repository() {
			# Parse our repo list
			parse_repository

			# Switch for verbose output
			VERBOSE=false

			while (( $# )); do
				case $1 in
					--verbose|-v)	VERBOSE=true
					;;
				esac
				shift
			done

			echo -e "\033[2mAvailable Repositories:\033[0m\n"

			# Iterate over each repository entry in the repository list
			while read REPO; do
				# The URL to the jar file
				local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
				# A descriptive name of the JAR file
				local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
				# The name of the file we want to store
				local REPO_FILE="$JAR_DIR/`basename $REPO_URL`"

				echo -e "\033[1m$REPO_NAME\033[0m"
				if ( $VERBOSE ); then
					echo -e "\033[2mURL:\033[0m\t$REPO_URL"
					echo -e "\033[2mFILE:\033[0m\t$REPO_FILE\n"
				fi
			done < $TMP_REPO_LIST
		}

		# Add an entry to the repository
		add_repository() {
			# Clear variables
			local REPO_URL="$1"
			local REPO_NAME="$2"

			# If nothing has been specified via the parameters, go to interactive mode
			if [ -z "$REPO_URL" ]; then
				echo -en "Please enter the repository's URL\nURL: "
				read REPO_URL
			fi

			if [ -z "$REPO_NAME" ]; then
				echo -en "Please enter the repository's name\nName: "
				read REPO_NAME
			fi

			# Store new repository in file
			echo "$REPO_URL#$REPO_NAME" >> $REPO_LIST 2> /dev/null || fail "New repository could not be saved"
		}

		# Remove an entry from the repository list
		remove_repository() {
			# Only argument: The Repo's name
			local REPO_NAME="$1"

			# If nothing has been specified via the parameters, go to interactive mode
			if [ -z "$REPO_NAME" ]; then
				tell "Please enter the repository's name\nName: "
				read REPO_NAME
			fi

			# Remove repo from the list if it is inside
			fileop -e remove  "#$REPO_NAME" "$REPO_LIST" 2> /dev/null
			
		}

		local CMD=$1
		shift
	
		# Switch commands
		case $CMD in
			list|ls)		list_repository "$@"
			;;
			add)			add_repository "$@"
			;;
			remove|delete|rm)	remove_repository "$@"
			;;
			--help|-h|help)		echo -e "$USAGE" | /usr/bin/less -r
						exit 0
			;;
			*)			error "Unknown command '$CMD'\nTry --help for help"
						exit 1
		esac
	}

	# List available JAR files
	list_jars() {
		# Change to the JARs' folder
		cd $JAR_DIR 2> /dev/null || fail "JAR file directory not found"

		# Parse arguments
		case $1 in
			-a|--all)	ls --color=auto -alF
			;;
			*)		ls --color=auto *.jar 2> /dev/null || fail "No jar files in the JARs' directory.\nTry\n\t$0 jar upgrade"
		esac
	}

	# Check if updates for JAR files are available
	update_jars() {
		# Change to temoprary directory
		cd "$JAR_REPO" > /dev/null 2> /dev/null || fail "Could not change to JAR repository directory"

		# Update counter
		local UPDATES=0

		# Skipping indicator
		local CONTINUE=false

		# Parse our repo list
		parse_repository

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The name of the file we want to store
			local REPO_FILE="$JAR_REPO/`date +%s`-`basename $REPO_URL`"
			# The latest file of the repo
			local LATEST_FILE="$JAR_REPO/`basename $REPO_URL`.latest"

			# Check if we specified aonly a selection 
			# of repos and skip unwanted ones
			for WANTED_REPO in "$@"; do
				CONTINUE=true

				if [ "$REPO_NAME" == "$WANTED_REPO" ]; then
					CONTINUE=false
					break
				fi		
			done

			$CONTINUE && continue

			# Download the JAR file
			tell "Retrieving \033[1m$REPO_NAME\033[0m\t"
			wget -q "$REPO_URL" -O "$REPO_FILE" 2> /dev/null || fail "[  failed   ]"
		
			# If the file exists...
			if [ -f "$LATEST_FILE" ]; then
				# ...and it is the same, we don't need to update it
				if ( cmp "$LATEST_FILE" "$REPO_FILE" > /dev/null 2> /dev/null ); then
					rm -f "$REPO_FILE" 2> /dev/null
					succ "[ up 2 date ]"
					continue
				fi
			fi

			ln -sf "$REPO_FILE" "$LATEST_FILE" 2> /dev/null

			# Increment update counter
			UPDATES=$(($UPDATES+1))

			succ "[  updated  ]"
		done < $TMP_REPO_LIST

		# Return value is number of updates
		return $UPDATES
	}

	# Upgrade Minecraft's JAR files
	upgrade_jars() {
		# Change to temoprary directory
		cd "$JAR_REPO" > /dev/null 2> /dev/null || fail "Could not change to temporary directory"

		# Upgrade counter
		local UPGRADES=0

		# Skipping indicator
		local CONTINUE=false

		# Parse our repo list
		parse_repository

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The latest file of the repo
			local LATEST_FILE="$JAR_REPO/`basename $REPO_URL`.latest"
			# The latest file of the repo
			local CURRENT_FILE="$JAR_DIR/`basename $REPO_URL`"
			# Check if we specified aonly a selection 
			# of repos and skip unwanted ones

			for WANTED_REPO in "$@"; do
				CONTINUE=true

				if [ "$REPO_NAME" == "$WANTED_REPO" ]; then
					CONTINUE=false
					break
				fi		
			done

			$CONTINUE && continue
		
			tell "JAR file from repo \033[1m$REPO_NAME\033[0m "
			# If the file exists...
			if [ -f "$LATEST_FILE" ]; then
				if [ -f "$CURRENT_FILE" ]; then
					# ...and it is the same, we don't need to update it
					if ( cmp "$CURRENT_FILE" "$LATEST_FILE" > /dev/null 2> /dev/null ); then
						echo "is up to date"
						continue
					fi
				fi

				ln -sf "`readlink $LATEST_FILE`" "$CURRENT_FILE" 2> /dev/null

				# Increment update counter
				UPGRADES=$(($UPGRADES+1))

				echo "has been upgraded"
			else
				fail "Please run '`basename $0` jar update' first"
			fi
		done < $TMP_REPO_LIST

		# Return value is number of updates
		return $UPDATES
	}


	local CMD=$1
	shift
	
	# Switch commands
	case $CMD in
		list|ls)		list_jars "$@"
		;;
		update)			update_jars "$@"
		;;
		upgrade)		upgrade_jars "$@"
		;;
		repository|repo)	repository "$@"
		;;
		--help|-h|help)		echo -e "$USAGE" | /usr/bin/less -r
					exit 0
		;;
		*)			error "Unknown command '$CMD'\nTry --help for help"
					exit 1
	esac
}

#############################
# Minecraft server commands #
#############################

# Send commands to server and print results
srv_exec() {
	# Per default, we don't want to see the verbose output
	local VERBOSE=false
	local SHOW_TAIL=false
	local WAIT_TIME=0.1

	# Switch options
	while (( $# )); do
		case $1 in
			--verbose|-v)	VERBOSE=true
					shift
			;;
			--show-tail|-s)	SHOW_TAIL=true
					shift
			;;
			--wait-time|-w)	WAIT_TIME=$2
					shift 2
			;;
			*)		break
		esac
	done

	# Execute a Java command on the server
	exec_cmd() {
		access_server "$SERVER_NAME"

		if ( srv_status > /dev/null 2> /dev/null ); then
			local CAT_PID="`mktemp`"
		
			# Delete tail if unwanted
			if ( ! $SHOW_TAIL ); then
				# Open stderr fifo for reading and discard the output
				(	
					cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
				) > /dev/null 2> /dev/null
				# Wait a short time
				sleep $WAIT_TIME 2> /dev/null || err "Could not sleep"
				# Close the sterr fifo
				kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
				# Remove PID file
				rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
			fi

			# Open stderr fifo for reading
			(	
				cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
			) 2> /dev/null
			# Echo command into stdin fifo
			echo $@ > stdin 2> /dev/null || fail "Could not execute command \"$@\""
			# Wait a short time
			sleep $WAIT_TIME 2> /dev/null || err "Could not sleep"
			# Close the sterr fifo
			kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
			# Remove PID file
			rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
		else
			err "Server is not running"
		fi
	}

	if ( $VERBOSE ); then
		exec_cmd $@
	else 
		exec_cmd $@ | cut -d " " -f 4-
	fi
}

# List players that are logged in
# Return 0 iff there are players on the server
# or 1 else
list_players() {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1

	srv_exec list | tail -n +2 > $TMP_PLAYERS 2> /dev/null

	if [ -n "`cat $TMP_PLAYERS`" ]; then
		cat "$TMP_PLAYERS"
		RETVAL=0
	else
		echo "There are no players on the server"
	fi
	
	rm -f $TMP_PLAYERS 2> /dev/null 
	return $RETVAL	
}

# Display count of players logged in
# Return 0 iff there are players on the server
# or 1 else
player_count()  {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1
	
	srv_exec list | head -n 1 | awk '{ print $3 }' | cut -d "/" -f 1 > $TMP_PLAYERS 2> /dev/null
	cat $TMP_PLAYERS
	PLAYERS=`cat $TMP_PLAYERS`

	if [ $PLAYERS -gt 0 ]; then
		RETVAL=0
	fi

	rm -f $TMP_PLAYERS 2> /dev/null
	return $RETVAL
}

##################################
# Init/Systemd control functions #
##################################

# Determine status of server
srv_status() {
	if [ -f "/lib/systemd/system/minecraft@.service" ]; then
		/usr/bin/systemctl status minecraft@$SERVER_NAME.service
	else
		/etc/init.d/minecraft status "$SERVER_NAME" || fail "Could determine $1 of server $SERVER_NAME"
	fi
}

######################################################################################################################

###############
# Main script #
###############

# Read command
CMD=$1
shift

# Check if we are a valid user
if [ "$USER" != "$MC_USER" ]; then
	fail "You need to be $MC_USER to run this"
fi

# Switch commands and execute appropriate functions
case $CMD in
	init)			init "$@"
	;;
	list)			list "$@"
	;;
	add)			add "$@"
	;;
        jar)			jar "$@"
	;;
	""|help|--help|-h)	case $1 in
					passwd)		passwd --help
					;;
					jar)		jar --help
					;;
					*)	echo -e "$USAGE" | /usr/bin/less -r
				esac
	;;
	--version)		echo -e "`basename $0`-$VERSION.$ARCH"
	;;
	*)			# If no commands match, we assume, that
				# the argument is the server's name
				SERVER_NAME=$CMD

				# Change securely to the server's directory
				access_server "$SERVER_NAME"

				# Switch commands on the servers
				CMD=$1
				shift

				case $CMD in

					remove)			remove "$@"
					;;
					passwd)			passwd "$@"
					;;
					configure|config|cfg)	configure "$@"
					;;
					properties|props|pro)	properties "$@"
					;;
					backup)			backup "$@"
					;;
					restore)		restore "$@"
					;;
					reset)			reset "$@"
					;;
					status)			srv_status "$@"
					;;
					exec)			srv_exec "$@"
					;;
					players)		list_players "$@"
					;;
					player-count)		player_count "$@"
					;;
					"")			err "No command entered\nType\n\t$0 --help\nfor information about usage"
					;;
					# Assume that we want to run a command of the Java program
					# iff nothing else applies
					*)			srv_exec "$CMD" "$@"
				esac
esac

# Return the state of the last command
exit $?
