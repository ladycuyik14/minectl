#! /bin/bash
#
#	minectl - Control a minecraft server
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

#######################
# Version information #
#######################

VERSION=5.2
ARCH=noarch

####################
# Global variables #
####################

# Define default minectl user
MC_USER=minectl

# Define home directory
MC_HOME="/home/$MC_USER"

# Binaries' directory
BIN_DIR="/usr/local/bin"

# Library directory
LIB_DIR="/usr/local/libexec/minectl"

# Servers directory
SERVERS_DIR="$MC_HOME/servers"

# JARs' directory
JAR_DIR="$LIB_DIR/jar"

# Define temporary directory
TMP_DIR="/tmp"

# Define our configuration file name
SERVER_CONFIG="./.mined.cfg"

# The server's properties file
SERVER_PROPERTIES="./server.properties"

# The server's white-list
WHITE_LIST="./white-list.txt"

# The server's ops-list
OP_LIST="./ops.txt"

# Define shared library
MC_LIB="$LIB_DIR/minelib"

# Define repository list
REPO_LIST="$LIB_DIR/.repolist"

# Set temporary repository for re-formatted repo list
TMP_REPO_LIST=$TMP_DIR/repolist.tmp

# Synopsis of usage for user information
USAGE="\033[1mUsage:	`basename $0` [COMMAND]\033[0m,
\033[1mor		`basename $0` <SERVER_NAME> [SERVER_SPECIFIC_COMMAND]\033[0m

\033[1mCOMMANDS\033[0m
	\033[1minit\033[0m
		Initialize the server manager

	\033[1mlist [--verbose|--very-verbose]\033[0m
		List available servers

	\033[1madd <server_name> [--jar <jar_file>]\033[0m
		Add a new server
		You can specify a jar file to be used or select it interactively

	\033[1mcheck-update\033[0m
		Check for updates for the JAR files
		Return number of available updates

	\033[1mupdate\033[0m
		Update the JAR files

	\033[1mrepo [REPO_COMMAND]\033[0m
		Manage the JAR files repository
		See '`basename $0` --help repo' for further information

	\033[1mlsjar [--all]\033[0m
		List available JAR files
		Or list all files in the JARs' folder by using the --all switch

\033[1mSERVER SPECIFIC COMMANDS\033[0m
	\033[1mremove [--force]\033[0m
		Entirely remove a server from the disk
		You can avoid querying by using the --force switch

	\033[1mpasswd [PASSWD_COMMAND] <user_name>\033[0m
		Manage the server's users
		See '`basename $0` --help passwd' for further information

	\033[1mconfigure, config, cfg\033[0m
		Show the server's meta-variables,
	\033[1mor: configure <variable> <value>\033[0m
		Configure the server meta-variables
	\033[1mor: configure --clear, --unset <variable> \033[0m
		Unset the specified variable
	\033[1mor: configure --remove, --delete <variable>\033[0m
		Delete the specified variable

	\033[1mproperties, props, pro\033[0m
		Show variables in the appropriate server.properties file
	\033[1mor: properties <variable> <value>\033[0m
		Configure variables in the appropriate server.properties file
	\033[1mor: properties --clear, --unset <variable>\033[0m
		Unset the specified variables in the appropriate server.properties file
	\033[1mor: properties --remove, --delete <variable>\033[0m
		Delete the specified variables in the appropriate server.properties file

	\033[1mbackup [backup_name]\033[0m
		Create a backup of the server
		You can specify the name of the backup to be saved

	\033[1mrestore [--clean] [backup_name..]\033[0m
		Restore latest backup of the server	
		You can specify the name of the backup to be restored in backup_name instead of 
		restoring the latest one
		To erase the server's data before restoring (to clean it up) use the --clean switch, 
		which must be the first argument

	\033[1mset-jar <JAR_file>\033[0m
		Set <JAR_file> as the active JAR file for the server

	\033[1mreset [--keep-config]\033[0m
		Reset the server to default state (create a new server)
		Use the --keep-config switch to keep the server's configuration

	\033[1mexec [ARGS..] <MINECRAFT_SERVER_COMMAND>\033[0m
		Send commands to the server's stdin and print out replies
		Possible arguments are:
		--verbose,-v			Show verbose output
		--show-tail,-s			Show the tail of the pipe and 
						not only the command's results
		--wait-time,-w <seconds>	Specify waiting time in seconds
						to wait for the pipe to close again

\033[1mMETA\033[0m
	\033[1m--help\033[0m
		Print this infomation

	\033[1m--version\033[0m     		
		Print version information and exit
"

######################################################################################################################

###########################
# Miscellaneous functions #
###########################

# Clean up the server directory
clean() {
	# First parameter is the server name
	SERVER_NAME=$1
	shift

	# Change to server's directory
	access_server "$SERVER_NAME" || fail # XXX: Just to be sure!

	# Remove server directory's content
	rm -R * > /dev/null 2> /dev/null || fail "Server \"$SERVER_NAME\" could not be cleaned up"
}

# Parse the repository list
parse_repo() {
	# Check whehter the repository list exists
	test -f $REPO_LIST 2> /dev/null || fail "Checking for repository list failed"

	# Re-format repo file
	grep -v ";" $REPO_LIST > $TMP_REPO_LIST 2> /dev/null || fail "Parsing repository file failed"
}

# Indicate failure when loading of shared library fails
lib_fail() {
	echo "Could not load shared library: $MC_LIB" 1>&2
	exit 1
}

#########################
# Source shared library #
#########################
. $MC_LIB 2> /dev/null || lib_fail

######################################################################################################################

##################
# Main functions #
##################

# Initialize the minecraft server installation and configuration after installation
# This should be done interactively
init() {
	# Change to home directory
	cd $MC_HOME 2> /dev/null || fail "Cannot change to home directory"

	# Check if no servers are configured yet
	if [ -z "`ls $SERVERS_DIR`" ]; then
		echo -en "What name shall your first server have?\nServer name: "
		read SERVER_NAME

		# Check if we already have some JAR files at hand (although this should not be the case)
		if ( ls_jar ); then
			# Ask the user which jar file shall be used
			echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
			read JAR_FILE
		else
			# Ask the user to update the system
			if ( ask "Do you want to run an update now?" ); then
				update
				ls_jar
				echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
				read JAR_FILE
			else
				echo "Please run an update manually and try again."
				exit 1
			fi
		fi

		# Add the new server
		add "$SERVER_NAME" --jar "$JAR_FILE" 

	# If we already have servers, don't initialize
	else
		succ "There are already servers.\nNo initialization required."
	fi		
}

# Add a server
add() {
	# First parameter is the server name
	local SERVER_NAME=$1
	shift

	# JAR file to be used
	local JAR_FILE=

	# Switch options
	while (( $# )); do
		case $1 in
			--jar)	JAR_FILE=$2
				shift
			;;
			*)	error "Unknown parameter '$1'"
		esac
		shift
	done

	# Change to servers directory
	cd $SERVERS_DIR 2> /dev/null || fail "Could not change to server directory"

	# Check if we specified a server name
	if [ -n "$SERVER_NAME" ]; then
		# Check whether no such file or folder already exists
		if [ -e "$SERVER_NAME" ]; then
			# If there's already such a directory, we assume that the server already exists
			if [ -d "$SERVER_NAME" ]; then
				succ "Server $SERVER_NAME already exists"
				exit 0
			# If the thing with the server's name is not a directory, we give up :-(
			else
				fail "A file named $SERVER_NAME already exists\nPlease remove it."
			fi				
		else
			# Create the server
			mkdir "$SERVER_NAME" 2> /dev/null || fail "Could not create server's directory"
			cp $SERVER_CONFIG "$SERVER_NAME" 2> /dev/null || fail "Could not copy skeleton server configuration"

			# Change to new server
			access_server "$SERVER_NAME"

			# If JAR file was not specified, let the user select one iteractively
			if [ -z "$JAR_FILE" ]; then
				setjar
			# Or  use it
			else
				setjar "$JAR_FILE"
			fi

			# Create basic minecraft-specific files
			touch server.properties ops.txt white-list.txt 2> /dev/null || err "Could not create basic config files"
		fi
	# If no name was specified, we cannot create a server
	else
		fail "No server name specified"
	fi		
}

# Remove a server
remove() {
	# As default, ask again, before removing the server
	local FORCE=false

	# Switch options
	while (( $# ));do
		case $1 in
			--force)	FORCE=true
			;;
			*)		error "Unknown parameter '$1'"
		esac
		shift
	done

	# Do we really want to remove the server?
	local REMOVE=false

	# Check if we want to remove non-interactively
	if ( $FORCE ); then
		REMOVE=true
	else
		# Ask the user if they really wants to remove the server
		ask "Do you really want to remove the server '$SERVER_NAME'?" && REMOVE=true
	fi

	# If we finally want to remove the server
	if ( $REMOVE ); then
		# Change to server's directory
		access_server "$SERVER_NAME"

		# Change to parent folder
		cd .. 2> /dev/null || fail "Cannot change to parent directory"

		# Remove stuff
		rm -R "$SERVER_NAME" && succ "Server \"$SERVER_NAME\" removed" || fail "Failed to remove server\"$SERVER_NAME\""
	fi
}

# List available servers
list() {
	# Define tamporary server list	
	local SERVER_LIST=$TMP_DIR/mined-server-list.tmp

	# Don't be verbose by default
	local VERBOSE=false
	local VERY_VERBOSE=false

	# List all folders (servers) in the servers directory
	cd "$SERVERS_DIR" 2> /dev/null && ls_dir 2> /dev/null > $SERVER_LIST

	# Switch options
	while (( $# ));do
		case $1 in
			--verbose|-v)		VERBOSE=true
			;;
			--very-verbose|-vv)	VERBOSE=true
						VERY_VERBOSE=true
			;;
			*)			error "Unknown parameter '$1'"
		esac
		shift
	done

	# Iterate over all servers in the list
	while read SERVER_NAME; do
		# Print the server's name
		# Bold if verbose
		$VERBOSE && echo -en "\033[1m"
		echo -en "$SERVER_NAME"
		$VERBOSE && echo -e "\033[0m" || echo ""

		# Print some more information in verbose mode
		if ( $VERBOSE ); then
			access_server "$SERVER_NAME"
			echo -e "	\033[1mCONFIGURATION:\033[0m"
			configure
			if ( $VERY_VERBOSE ); then
				echo -e "	\033[1mPROPERTIES:\033[0m"
				properties
			fi
		fi
	done < $SERVER_LIST
}

# Configure minecraft server installation and configuration
configure() {
	# Set temporary configuration file
	local TMP_SERVER_CONFIG=$TMP_DIR/.mined.cfg.tmp

	# Print configuration of server, if no arguments are specified
	if [ $# -eq 0 ]; then
		# Delete comments and empty lines from config file
		grep -vE "^#|^$" $SERVER_CONFIG > $TMP_SERVER_CONFIG 2> /dev/null || fail "Configuration file is missing"

		# Print used JAR file	
		echo -e "	JAR_FILE=`readlink minecraft_server.jar 2> /dev/null`"

		# Print configuration file content
		while read LINE; do
			echo -e "	$LINE"
		done < $TMP_SERVER_CONFIG
	else
		# Switch arguments and set variables
		while (( $# )); do
			# Put var to upper case
			declare -u VAR=$1

			# Change variable
			set_var $VAR $2 $SERVER_CONFIG
			shift 2

		done
		# Print new configuration after modifications
		configure
	fi
}

# Configure a server's properties
properties() {
	# Set temporary properties file
	local TMP_SERVER_PROPERTIES=$TMP_DIR/server_properties.tmp

	# Print server properties, if no arguments are specified
	if [ $# -eq 0 ]; then
		# Delete comments and empty lines from config file
		grep -vE "^#|^$" $SERVER_PROPERTIES > $TMP_SERVER_PROPERTIES 2> /dev/null || fail "Properties file is missing"

		# Print configuration file content
		while read LINE; do
			echo -e "	$LINE"
		done < $TMP_SERVER_PROPERTIES
	else
		# Process variable / value pairs
		while (( $# ));do
			# Put var to lower case
			declare -l VAR=$1

			# Change variable
			set_var $VAR "$2" $SERVER_PROPERTIES
			shift 2
		done

		# Print new properties after modifications
		properties
	fi
}
	
# Manage a server's users
passwd() {
	#################
	# Set variables #
	#################

	# Set temporary file
	local TMP=$TMP_DIR/`basename $0`-$CMD.tmp

	# Usage information
	local USAGE="\033[1mUsage: `basename $0` <server_name> passwd <COMMAND [user_name]>*\033[0m

\033[1mCOMMANDS\033[0m
	\033[1madd, whitelist		<user_name>\033[0m
		Add <user_name> to the white-list

	\033[1mremove, blacklist	<user_name>\033[0m
		Remove <user_name> from white-list

	\033[1mop			<user_name>\033[0m
		Add <user_name> to the ops list

	\033[1mdeop			<user_name>\033[0m
		Remove <user_name> from the ops list

	\033[1mstatus			<user_name>\033[0m
		List status of <user_name>

	\033[1mprint, list\033[0m
		Print current status, white- and ops-list

	\033[1mlock\033[0m
		Lock server by putting it into online mode and enabling the white-list (recommended)

	\033[1munlock\033[0m
		Unlock server by putting it into offline mode an disabling the white-list (not recommended)

	\033[1mhelp\033[0m
		Print this information
"

	####################
	# Passwd functions #
	####################

	# Check if we are given a valid user name
	valid_user() {
		# Fail if no user name has been given
		if [ -z "$1" ]; then
			fail "No user name given"
		fi
	}

	# Check whether a certain user is white-listed
	is_whitelisted() {
		valid_user "$1"
		if ( is_in "$1" "$WHITE_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1mwhitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		fi
	}

	# Check whether a certain user is an operator
	is_op() {
		valid_user "$1"
		if ( is_in "$1" "$OP_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1man operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Add a user to the white-list, iff he's not in it yet
	whitelist() {
		valid_user "$1"
		if ( ! is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( add_to "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed whitelisting $1\033[0m on server \033[1m$SERVER_NAME\033[0m'.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1malready\033[0m whitelisted on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Remove user from the white list, iff he's in it
	remove() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			deop "$1" 2> /dev/null
			if ( remove_from "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 removed\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed removing $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Add a user to the operators list
	op() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( ! is_op "$1" > /dev/null 2> /dev/null ); then		
				if ( add_to "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
					succ "User \033[1m$1\033[0m is \033[1mnow an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
				else
					err "\033[1mFailed opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
				fi
			else
				err "User \033[1m$1\033[0m is \033[1malready an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Delete a user from the operators list
	deop() {
		valid_user "$1"
		if ( is_op "$1" > /dev/null 2> /dev/null ); then
			if ( remove_from "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1\033[0m is \033[1mno longer an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed de-opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Print the status of a user
	status() {
		valid_user "$1"
		if ( is_whitelisted "$1" ); then	
			is_op "$1"
		fi
	}

	# Print the status of the whole server mode, white-list and ops-list configuration
	print() {
		# Determine mode
		echo -en "Server \033[1m$SERVER_NAME\033[0m is configured as "
		if [ "`grep "online-mode" "$SERVER_PROPERTIES" 2> /dev/null | cut -d "=" -f 2 2> /dev/null`" == "true" ]; then
			echo -en "\033[1monline\033[0m"
		else
			echo -en "\033[1moffline\033[0m"
		fi

		# Determine whether white-list is enabled
		echo -n ", its white-list is "
		if [ "`grep "white-list" "$SERVER_PROPERTIES" 2> /dev/null | cut -d "=" -f 2 2> /dev/null`" == "true" ]; then
			echo -e "\033[1menabled\033[0m."
		else
			echo -e "\033[1mdisabled\033[0m."
		fi	

		# Display users
		echo -e "\n\033[1mWhitelisted users:\033[0m"
		cat "$WHITE_LIST" 2> /dev/null
		echo -e "\n\033[1mOperators:\033[0m"
		cat "$OP_LIST" 2> /dev/null
		echo ""
	}

	# Lock the server by putting it into online mode and enabling the white-list
	lock() {
		remove_any_from "online-mode" "$SERVER_PROPERTIES" && remove_any_from "white-list" "$SERVER_PROPERTIES" && echo "online-mode=true" >> "$SERVER_PROPERTIES" && echo "white-list=true" >> "$SERVER_PROPERTIES" && succ "Server locked." || err "Server locking failed."
	}

	# Unlock the server by putting it into offline mode and disabling the white-list
	# XXX: This is not recommended. We anyway want to offer this feature for there 
	# might be user that want to run an open game server e.g. on networking parties
	unlock() {
		remove_any_from "online-mode" "$SERVER_PROPERTIES" && remove_any_from "white-list" "$SERVER_PROPERTIES" && echo "online-mode=false" >> "$SERVER_PROPERTIES" && echo "white-list=false" >> "$SERVER_PROPERTIES" && succ "Server unlocked." || err "Server unlocking failed." 
	}

	# Switch commands
	while (( $# )); do
		case $1 in
			add|whitelist)		whitelist $2
						shift
			;;
			remove|blacklist)	remove $2
						shift
			;;
			op)			op $2
						shift
			;;
			deop)			deop $2
						shift
			;;
			status)			status $2
						shift
			;;
			lock)			lock
			;;
			unlock)			unlock
			;;
			""|list|print)		print
			;;
			-h|--help|help)		echo -e "$USAGE"
						exit 0
			;;
			*)			fail "Unknown argument '$1'. Try:\n\t\$ $0 $CMD --help"
		esac
		shift
	done
}

# Create a backup of the server
backup() {
	# Set current time and date as default backup name
	local BACKUP_NAME="$SERVER_NAME-`date +%Y.%m.%d-%H.%M`"
	
	# Set parameters as backup name if specified
	if [ $# -gt 0 ]; then
		BACKUP_NAME="$@"
	fi

	# Create the backup as a gzip compressed tar archive, but with the custom *.mcb suffix 
	tar czf "$MC_HOME/backup/$BACKUP_NAME.mcb" * > /dev/null 2> /dev/null 
	# The backup worked fine, iff tar returns something smaller or equal 1
	test $? -le 1 && return 0 || fail "Could not create backup"
}

# Restore the server
restore() {
	# Assume latest backup shall be restored
	local BACKUP_NAME="`ls -tl $MC_HOME/backup/$SERVER_NAME-* 2> /dev/null | head -n1 | awk '{print $9}'`"
	local BACKUP=""

	# We don't want to clean the server directory by default
	local CLEAN=false
	
	# Switch options
	while (( $# )); do
		case "$1" in
			"--clean"|"-c")		CLEAN=true
			;;
			*)			BACKUP_NAME="$@"
						break
		esac
     		shift
	done

	# Check whether the backup file is present...
	# ... as the file itself (full or relative file path)...
	if [ -f "$BACKUP_NAME" ]; then
		BACKUP="$BACKUP_NAME"
	# ... or as the file's name located in the backup folder ...
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME"
	# ... or finally as the file's name in the backup folder without the suffix specified.
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME.mcb" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME.mcb"
	# Fail otherwise
	else
		fail "Specified backup file could not be found"
	fi

	# Clean the server if wanted
	if ( $CLEAN ); then
		clean "$SERVER_NAME"
	fi

	# Perform restore
	tar xzf "$BACKUP" > /dev/null 2> /dev/null && return 0 || fail "Could not restore backup"

	# The server must be restarted now
	echo "Server must be restarted"
}

# Reset the server
reset() {
	# As default we want to keep our configuration
	local KEEP_CONFIG=false
	local CFG_BACKUP=$TMP_DIR/minecraft-cfg-backup.tar.gz

	# Switch options
	while (( $# )); do
		case $1 in
			--erase-config|-ec|-e)	KEEP_CONFIG=false
			;;
			*)			error "Unrecognized argument '$1'"
		esac
		shift
	done

	# If we want to keep the configuration, we create a temporal archive from them
	# XXX: Do not mix this up with our server's main backup() function
	if ( $KEEP_CONFIG ); then
		tar czf $CFG_BACKUP banned-ips.txt banned-players.txt ops.txt server.properties white-list.txt 2> /dev/null || fail "Saving of configuration failed"
	fi

	# Remember used jar file
	local JAR_FILE=`readlink minecraft_server.jar`
	
	# Clean up the server
	clean "$SERVER_NAME" || fail

	# Link back to the active minecraft_server.jar
	ln -s $JAR_FILE minecraft_server.jar || err "Resetting JAR file failed"
	
	# If we wanted to keep our configuration, we now restore its backup	
	if ( $KEEP_CONFIG ); then
		tell "Restoring configuration\t\t\t"
		tar xzf $CFG_BACKUP 2> /dev/null || fail "Could not restore configuration"
		rm $CFG_BACKUP 2> /dev/null
	fi
		
	# The server should be restarted now
	echo "Server should be restarted"
}

# Check if updates for JAR files are available
check_update() {
	# Change to temoprary directory
	cd $TMP_DIR > /dev/null 2> /dev/null || fail "Could not change to temporary directory"

	# Update counter
	local UPDATES=0

	# Parse our repo list
	parse_repo

	# Iterate over each repository entry in the repository list
	while read REPO; do
		# Skip empty lines
		if [ -z "$REPO" ]; then
			continue
		fi

		# The URL to the jar file
		local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
		# A descriptive name of the JAR file
		local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
		# The name of the file we want to store
		local REPO_FILE=`basename $REPO_URL`

		# Make sure the repo file does not exist yet
		# TODO: This is no nice way to do that
		rm -f $REPO_FILE 2> /dev/null

		# Download the JAR file
		tell "Retrieving \"$REPO_NAME\"\t"
		wget -q "$REPO_URL" -O $REPO_FILE 2> /dev/null || fail
		
		# If the file exists...
		if [ -f $JAR_DIR/$REPO_FILE ]; then
			# ...and it is the same, we don't need to update it
			if ( cmp $JAR_DIR/$REPO_FILE $REPO_FILE > /dev/null 2> /dev/null ); then
				succ "[ up 2 date ]"
			else
				succ "[ outdated  ]"

				# Increment update counter
				UPDATES=$(($UPDATES+1))
			fi
		else
			succ "[ available ]"

			# Increment update counter
			UPDATES=$(($UPDATES+1))
		fi

	done < $TMP_REPO_LIST

	# Return value is number of updates
	return $UPDATES
}

# Update Minecraft's JAR files
update() {
	# Change to temoprary directory
	cd $TMP_DIR > /dev/null 2> /dev/null || fail "Could not change to temporary directory"

	# Indicator if something was updated
	local UPDATED=false

	# Parse our repo list
	parse_repo

	# Iterate over each repository entry in the repository list
	while read REPO; do
		# Skip empty lines
		if [ -z "$REPO" ]; then
			continue
		fi

		# The URL to the jar file
		local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
		# A descriptive name of the JAR file
		local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
		# The name of the file we want to store
		local REPO_FILE=`basename $REPO_URL`

		# Make sure the repo file does not exist yet
		# TODO: This is no nice way to do that
		rm -f $REPO_FILE 2> /dev/null

		# Download the JAR file
		tell "Retrieving \"$REPO_NAME\"\t"
		wget -q "$REPO_URL" -O $REPO_FILE 2> /dev/null || fail
		
		# If the file exists...
		if [ -f $JAR_DIR/$REPO_FILE ]; then
			# ...and it is the same, we don't need to update it
			if ( cmp $JAR_DIR/$REPO_FILE $REPO_FILE > /dev/null 2> /dev/null ); then
				succ "[ up 2 date ]"
				continue
			fi
		fi

		# Move the temporary file to it's targeted location
		mv $REPO_FILE $JAR_DIR/ 2> /dev/null && succ "[  updated  ]" || err

		# Mark that something has been updated
		UPDATED=true
	done < $TMP_REPO_LIST

	if ( $UPDATED ); then		
		# The servers using the updated JAR files should be restarted now
		echo -e "Updates have been installed\nAppropriate servers should be restarted"
	fi
}

# Manage the repository
repo() {
	# Usage information
	USAGE="\033[1mUsage: `basename $0` repo [COMMAND]\033[0m

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m
		List available repositories

	\033[1madd <URL> <name>\033[0m
		Add a repository

	\033[1mremove <name>\033[0m
		Remove a repository
"
	
	##################
	# Repo functions #
	##################

	# List available repositories
	ls_repo() {
		# Parse our repo list
		parse_repo

		echo -e "\nAvailable Repositories:\n\n|\t\t\033[1mName\033[0m\t\t|\t\t\t\033[1mURL\033[0m"

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# Skip empty lines
			if [ -z "$REPO" ]; then
				continue
			fi

			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The name of the file we want to store
			local REPO_FILE=`basename $REPO_URL`

			echo -e "+-------------------------------+-------------------------------------------------------------------------------"
			echo -e "|\t$REPO_NAME\t|\t$REPO_URL"
		done < $TMP_REPO_LIST
		echo -e "└-------------------------------┴-------------------------------------------------------------------------------"
	}

	# Add an entry to the repository
	add_repo() {
		# Clear variables
		local REPO_URL="$1"
		local REPO_NAME="$2"

		# If nothing has been specified via the parameters, go to interactive mode
		if [ -z "$REPO_URL" ]; then
			echo -en "Please enter the repository's URL\nURL: "
			read REPO_URL
		fi

		if [ -z "$REPO_NAME" ]; then
			echo -en "Please enter the repository's name\nName: "
			read REPO_NAME
		fi

		# Store new repository in file
		echo "$REPO_URL#$REPO_NAME" >> $REPO_LIST 2> /dev/null || fail "New repository could not be saved"
	}

	# Remove an entry from the repository list
	rm_repo() {
		# Only argument: The Repo's name
		local REPO_NAME="$1"

		# If nothing has been specified via the parameters, go to interactive mode
		if [ -z "$REPO_NAME" ]; then
			tell "Please enter the repository's name\nName: "
			read REPO_NAME
		fi

		# Remove repo from the list if it is inside
		if [ -n "`grep "#$REPO_NAME"$ $REPO_LIST 2> /dev/null`" ]; then
			grep -v "#$REPO_NAME"$ $REPO_LIST > $REPO_LIST.tmp 2> /dev/null && mv $REPO_LIST.tmp $REPO_LIST 2> /dev/null || fail "Could not remove repository"
		else
			err "Specified repository is not in the reposotories' file"
		fi
	}

	CMD=$1
	shift
	
	# Switch commands
	case $CMD in
		""|list)		ls_repo "$@"
		;;
		add)			add_repo "$@"
		;;
		remove)			rm_repo "$@"
		;;
		--help|-h|help)		echo -e "$USAGE"
					exit 0
		;;
		*)			error "Unknown command '$CMD'\nTry --help for help"
					exit 1
	esac
}

# List available JAR files
ls_jar() {
	# Change to the JARs' folder
	cd $JAR_DIR 2> /dev/null || fail "JAR file directory not found"

	# Parse arguments
	case $1 in
		-a|--all)	ls --color=auto -alF
		;;
		*)		ls --color=auto *.jar 2> /dev/null || fail "No jar files in the JARs' directory.\nTry\n\t$0 update"
	esac
}
	
# Set a new active JAR file
setjar() {
	# The second parameter is the JAR file
	local JAR_FILE_NAME=$1
	local JAR_FILE=""

	# Read JAR file interactively if not specified via a parameter
	if [ -z "$JAR_FILE_NAME" ]; then
		# Show available JAR files...
		if ( ls_jar ); then
			echo -en "Please specify the jar file that you want to use.\nJAR file: "
			read JAR_FILE_NAME
		# ...and exit if we don't have any
		else
			exit 1
		fi
	fi

	# Check if JAR file is present
	if [ -f $JAR_FILE_NAME ]; then
		JAR_FILE=$JAR_FILE_NAME
	elif [ -f $JAR_DIR/$JAR_FILE_NAME ]; then
		JAR_FILE=$JAR_DIR/$JAR_FILE_NAME
	elif [ -f $JAR_DIR/$JAR_FILE_NAME.jar ]; then
		JAR_FILE=$JAR_DIR/$JAR_FILE_NAME.jar
	else
		fail "Specified JAR file could not be found"		
	fi

	# Link to new JAR file
	unlink minecraft_server.jar 2> /dev/null; ln -sf $JAR_FILE minecraft_server.jar 2> /dev/null &&	echo "Server should be restarted" || fail "Could not set new JAR file"
}

# Send commands to server and print results
srv_exec() {
	# Per default, we don't want to see the verbose output
	local VERBOSE=false
	local SHOW_TAIL=false
	local WAIT_TIME

	# Switch options
	while (( $# )); do
		case $1 in
			--verbose|-v)	VERBOSE=true
					shift
			;;
			--show-tail|-s)	SHOW_TAIL=true
					shift
			;;
			--wait-time|-w)	WAIT_TIME=$2
					shift 2
			;;
			*)		break
		esac
	done

	# Execute a raw query
	exec_cmd() {
		access_server "$SERVER_NAME"

		local CAT_PID=/tmp/minectl.cat.pid
		
		# Delete tail if unwanted
		if ( ! $SHOW_TAIL ); then
			# Open stderr fifo for reading and discard the output
			(	
				cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
			) > /dev/null 2> /dev/null
			# Wait a short time
			sleep .1 2> /dev/null || err "Could not sleep"
			# Close the sterr fifo
			kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
			# Remove PID file
			rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
		fi

		# Open stderr fifo for reading
		(	
			cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
		) 2> /dev/null
		# Echo command into stdin fifo
		echo $@ > stdin 2> /dev/null || fail "Could not execute command \"$@\""
		# Wait a short time
		sleep .1 2> /dev/null || err "Could not sleep"
		# Close the sterr fifo
		kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
		# Remove PID file
		rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
	}

	if ( $VERBOSE ); then
		exec_cmd $@
	else 
		exec_cmd $@ | cut -d " " -f 4-
	fi
}

##################################
# Init/Systemd control functions #
##################################

# Enable a server for startup
enable() {
	if [ -f "/lib/systemd/system/minecraft@.service" ]; then
		runas root /usr/bin/systemctl enable minecraft@$SERVER_NAME.service
	else
		runas root /bin/echo "$SERVER_NAME" >> /etc/minectl.servers 2> /dev/null || fail "Could not enable server"
	fi
}

# Disable a server for starup
disable() {
	if [ -f "/lib/systemd/system/minecraft@.service" ]; then
		runas root /usr/bin/systemctl disable minecraft@$SERVER_NAME.service
	else
		runas root /bin/sed -i "/$SERVER_NAME/d" /etc/minectl.servers 2> /dev/null || fail "Could not disable server"
	fi
}

# Perform an execution on the respective init script
init() {
	if [ -f "/lib/systemd/system/minecraft@.service" ]; then
		runas root /usr/bin/systemctl $1 minecraft@$SERVER_NAME.service
	else
		runas root /etc/init.d/minecraft $1 "$SERVER_NAME" || fail "Could not $1 server $SERVER_NAME"
	fi
}

######################################################################################################################

###############
# Main script #
###############

# Read command
CMD=$1
shift

# Check if we are a valid user
if [ "$USER" != "$MC_USER" -a $EUID -ne 0 ]; then
	fail "You need to be either $MC_USER or root to run this"
fi

# Switch commands and execute appropriate functions
case $CMD in
	init)			init "$@"
	;;
	list)			list "$@"
	;;
	add)			add "$@"
	;;
	check-update)		check_update "$@"
	;;
	update)			update "$@"
	;;
	repo)			repo "$@"
	;;
        lsjar)			ls_jar "$@"
	;;
	""|help|--help|-h)	case $1 in
					passwd)	passwd --help
					;;
					repo)	repo --help
					;;
					*)	echo -e "$USAGE" | /usr/bin/less -r
				esac
	;;
	--version)		echo -e "`basename $0`-$VERSION.$ARCH"
	;;
	*)			# If no commands match, we assume, that
				# the argument is the server's name
				SERVER_NAME=$CMD

				# Change securely to the server's directory
				access_server "$SERVER_NAME"

				# Switch commands on the servers
				CMD=$1
				shift

				case $CMD in

					remove)			remove "$@"
					;;
					passwd)			passwd "$@"
					;;
					configure|config|cfg)	configure "$@"
					;;
					properties|props|pro)	properties "$@"
					;;
					backup)			backup "$@"
					;;
					restore)		restore "$@"
					;;
					reset)			reset "$@"
					;;
					set-jar|jar)		setjar "$@"
					;;
					exec)			srv_exec "$@"
					;;
					enable)			enable
					;;
					disable)		disable
					;;
					start)			init start
					;;
					stop)			init stop
					;;
					restart)		init restart
					;;
					status)			init status
					;;
					"")			err "No command entered\nType\n\t$0 --help\nfor information about usage"
					;;
					*)			err "Unrecognized command '$CMD'\nType\n\t$0 --help\nfor information about usage"
				esac
esac

# Return the state of the last command
exit $?
