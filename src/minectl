#! /bin/bash
#
#	minectl - Control a minecraft server
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

#######################
# Version information #
#######################

VERSION=5.6
ARCH=noarch

####################
# Global variables #
####################

# Define default minectl user
MC_USER=minectl

# Define home directory
MC_HOME="/home/$MC_USER"

# Binaries' directory
BIN_DIR="/usr/local/bin"

# Library directory
LIB_DIR="/usr/local/libexec/minectl"

# Servers directory
SERVERS_DIR="$MC_HOME/servers"

# JARs' directory
JAR_DIR="$LIB_DIR/jar"

# Define temporary directory
TMP_DIR="`mktemp -d`"

# Define our configuration file name
SERVER_CONFIG="./.mined.cfg"

# The server's properties file
SERVER_PROPERTIES="./server.properties"

# The server's white-list
WHITE_LIST="./white-list.txt"

# The server's ops-list
OP_LIST="./ops.txt"

# Define shared library
MC_LIB="$LIB_DIR/minelib"

# Define repository list
REPO_LIST="$LIB_DIR/.repolist"

# Set temporary repository for re-formatted repo list
TMP_REPO_LIST="`mktemp`"
	
# List of changed variables that have
# been altered by the config() or 
# properties() function
CHANGED_VARS=

# Global status if the server is running
# used to determine whether it should be 
# rstarted after shutdown operations
SERVER_RUNNING=

# Synopsis of usage for user information
USAGE="Usage:	\033[1m`basename $0`\033[0m [\033[1mINDEPENDENT_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m \033[3mSERVER_NAME\033[0m [\033[1mSERVER_SPECIFIC_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m [\033[1mMETA_COMMAND\033[0m]

\033[1mINDEPENDENT COMMANDS\033[0m
	\033[1minit\033[0m
		Initialize the server manager.

	\033[1mlist\033[0m [\033[1m--verbose\033[0m, \033[1m--very-verbose\033[0m]
		List available servers.

	\033[1madd\033[0m \033[3mserver_name\033[0m [\033[1m--jar\033[0m \033[3mjar_file\033[0m]
		Add a new server. 
		You can specify a jar file to be used or select it interactively.

	\033[1mcheck-update\033[0m
		Check for updates for the JAR files.
		Return number of available updates.

	\033[1mupdate\033[0m
		Update the JAR files.

	\033[1mrepo\033[0m [\033[1mREPO_COMMAND\033[0m]
		Manage the JAR files repository.
		See \033[1m`basename $0` --help repo\033[0m for further information.

	\033[1mlsjar\033[0m [\033[1m--all\033[0m]
		List available JAR files.
		Or list all files in the JARs' folder by using the \033[1m--all\033[0m switch.

\033[1mSERVER SPECIFIC COMMANDS\033[0m
	\033[1mremove\033[0m [\033[1m--force\033[0m]
		Entirely remove a server from the disk.
		You can avoid querying by using the \033[1m--force\033[0m switch.

	\033[1m\033[3mServer configuration\033[0m
		\033[1mpasswd\033[0m [\033[1mPASSWD_COMMAND\033[0m \033[3muser_name\033[0m]
			Manage the server's users.
			See \033[1m`basename $0` --help passwd\033[0m for further information.

		\033[1mconfigure\033[0m, \033[1mconfig\033[0m or \033[1mcfg\033[0m
			Show the server's meta-configuration.
		\033[1mconfigure\033[0m \033[3mvariable\033[0m \033[4mvalue\033[0m
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's meta-configuration file.
		\033[1mconfigure\033[0m \033[1m--clear\033[0m, \033[1m--unset\033[0m \033[3mvariable\033[0m
			Unset \033[3mvariable\033[0m in the server's meta-configuration file.
		\033[1mconfigure\033[0m \033[1m--remove\033[0m, \033[1m--delete\033[0m \033[3mvariable\033[0m
			Delete \033[3mvariable\033[0m from the server's meta-configuration file.

		\033[1mproperties\033[0m, \033[1mprops\033[0m or \033[1mpro\033[0m
			Show the appropriate server.properties data.
		\033[1mproperties\033[0m \033[3mvariable\033[0m \033[4mvalue\033[0m
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's server.properties file.
		\033[1mproperties\033[0m \033[1m--clear\033[0m, \033[1m--unset\033[0m \033[3mvariable\033[0m
			Unset \033[3mvariable\033[0m in the server's server.properties file.
		\033[1mproperties\033[0m \033[1m--remove\033[0m, \033[1m--delete\033[0m \033[3mvariable\033[0m
			Delete \033[3mvariable\033[0m from the server's server.properties file.

		\033[1mset-jar\033[0m \033[3mJAR_file\033[0m
			Set \033[3mJAR_file\033[0m as the active JAR file for the server.

	\033[1m\033[3mBackup, Restore and Reset\033[0m
		For \033[1mbackup\033[0m, \033[1mrestore\033[0m and \033[1mreset\033[0m you can use the
			following common options:
			\033[1m--force\033[0m
				To activate non-interactive mode in operations.
			\033[1m--grace-time\033[0m \033[3mgrace_time\033[0m
				To set the grace time in seconds for when the 
				appropriate server will be shut down (default: 10).
			\033[1m--message\033[0m \033[3mmessage\033[0m
				To specify the message send to users on the server.

		\033[1mbackup\033[0m [\033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Create a backup of the server.
			You can specify the name of the backup to be saved.

		\033[1mrestore\033[0m [\033[1m--clean\033[0m, \033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Restore latest backup of the server.
			You can specify the name of the backup to be restored in \033[3mbackup_name\033[0m 
			instead of restoring the latest one.
			To erase the server's data before restoring (to clean it up) use the 
			\033[1m--clean\033[0m switch, which must be the first argument.

		\033[1mreset\033[0m [\033[1m--erase-config\033[0m, \033[1mCOMMON_OPTIONS\033[0m]\033[0m
			Reset the server to its initial state.
			Use the \033[1m--erase-config\033[0m switch to also erase the server's configuration.

	\033[1m\033[3mInit / Systemd service control\033[0m
		\033[1mservice\033[0m [\033[1mSERVICE_COMMAND\033[0m]
		        Manage the respctive system service.
		        See \033[1m`basename $0` --help service\033[0m for further information.

	\033[1m\033[3mJava program commands\033[0m
		\033[1mexec\033[0m [\033[1mARGS\033[0m] \033[3mMINECRAFT_SERVER_COMMAND\033[0m
			Send commands to the server's stdin and print out replies
			Possible arguments are:
			\033[1m--verbose\033[0m, \033[1m-v\033[0m
				Show verbose output.
			\033[1m--show-tail\033[0m, \033[1m-s\033[0m
				Show the tail of the pipe and
				not only the command's results.
			\033[1m--wait-time\033[0m, \033[1m-w\033[0m \033[3mseconds\033[0m
				Specify waiting time in seconds
				to wait for the pipe to close again.

		\033[1mplayers\033[0m
		        List players logged in to the server
	
		\033[1mplayer-count\033[0m
		        List count of players logged in to the server.

		\033[3mMINECRAFT_JAVA_COMMAND\033[0m [\033[3mARGS\033[0m]
		        If none of the aforementioned commands apply, minectl will
		        interpret the command as command for the Java program.

\033[1mMETA COMMANDS\033[0m
	\033[1m--help\033[0m
		Print this infomation

	\033[1m--version\033[0m     		
		Print version information and exit
"

######################################################################################################################

###########################
# Miscellaneous functions #
###########################

# Clean up the server directory
clean() {
	# First parameter is the server name
	SERVER_NAME=$1
	shift

	# Change to server's directory
	access_server "$SERVER_NAME" || fail # XXX: Just to be sure!

	# Remove server directory's content
	rm -R * > /dev/null 2> /dev/null || fail "Server \"$SERVER_NAME\" could not be cleaned up"
}

# Parse the repository list
parse_repo() {
	# Check whehter the repository list exists
	test -f $REPO_LIST 2> /dev/null || fail "Checking for repository list failed"

	# Re-format repo file
	grep -v ";" $REPO_LIST > $TMP_REPO_LIST 2> /dev/null || fail "Parsing repository file failed"
}

# Shut down the server displaying a message
# after a short grace time
# shutdown <message> <grace_time> <force>
shutdown() {
	local MESSAGE="$1"
	local GRACE_TIME=$2
	local FORCE=$3

	# Check whether the server is running
	if ( service status ); then
		SERVER_RUNNING=true
		# If we force it, just shut it down ...
		if ( $FORCE ); then
			exec_srv say "$MESSAGE"
			if [ $GRACE_TIME -gt 0 ]; then
				exec_srv say "You've got $GRACE_TIME seconds to log out"
				sleep $GRACE_TIME
			fi

			service stop > /dev/null 2> /dev/null
		# ... or else ask the user to decide
		else
			if ( ask "Do you really want to shut down the server?" ); then
				exec_srv say "$MESSAGE"
				if [ $GRACE_TIME -gt 0 ]; then
					exec_srv say "You've got $GRACE_TIME seconds to log out"
					sleep $GRACE_TIME
				fi

				service stop > /dev/null 2> /dev/null
			else
				fail "Aborting..."
			fi
		fi
	else
		SERVER_RUNNING=false
	fi
}

# Restart the server after it was shut down:
# restart <force>
restart() {
	local FORCE=$1

	if ( $SERVER_RUNNING ); then
		if ( $FORCE ); then
			service start > /dev/null 2> /dev/null
		else
			if ( ask "Restart the server now?" ); then
	                        service start > /dev/null 2> /dev/null
			fi
		fi
	fi
}



# Indicate failure when loading of shared library fails
lib_fail() {
	echo "Could not load shared library: $MC_LIB" 1>&2
	exit 1
}

#########################
# Source shared library #
#########################
. $MC_LIB 2> /dev/null || lib_fail

######################################################################################################################

##################
# Main functions #
##################

# Initialize the minecraft server installation and configuration after installation
# This should be done interactively
init() {
	# Change to home directory
	cd $MC_HOME 2> /dev/null || fail "Cannot change to home directory"

	# Check if no servers are configured yet
	if [ -z "`ls $SERVERS_DIR`" ]; then
		echo -en "What name shall your first server have?\nServer name: "
		read SERVER_NAME

		# Check if we already have some JAR files at hand (although this should not be the case)
		if ( ls_jar ); then
			# Ask the user which jar file shall be used
			echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
			read JAR_FILE
		else
			# Ask the user to update the system
			if ( ask "Do you want to run an update now?" ); then
				update
				ls_jar
				echo -en "Which one of the listed JAR files do you want to use for your first server?\nJAR file: "
				read JAR_FILE
			else
				echo "Please run an update manually and try again."
				exit 1
			fi
		fi

		# Add the new server
		add "$SERVER_NAME" --jar "$JAR_FILE" 

	# If we already have servers, don't initialize
	else
		succ "There are already servers.\nNo initialization required."
	fi		
}

# Add a server
add() {
	# First parameter is the server name
	local SERVER_NAME=$1
	shift

	# JAR file to be used
	local JAR_FILE=

	# Switch options
	while (( $# )); do
		case $1 in
			--jar)	JAR_FILE=$2
				shift
			;;
			*)	error "Unknown parameter '$1'"
		esac
		shift
	done

	# Change to servers directory
	cd $SERVERS_DIR 2> /dev/null || fail "Could not change to server directory"

	# Check if we specified a server name
	if [ -n "$SERVER_NAME" ]; then
		# Check whether no such file or folder already exists
		if [ -e "$SERVER_NAME" ]; then
			# If there's already such a directory, we assume that the server already exists
			if [ -d "$SERVER_NAME" ]; then
				succ "Server $SERVER_NAME already exists"
				exit 0
			# If the thing with the server's name is not a directory, we give up :-(
			else
				fail "A file named $SERVER_NAME already exists\nPlease remove it."
			fi				
		else
			# Create the server
			mkdir "$SERVER_NAME" 2> /dev/null || fail "Could not create server's directory"
			cp $SERVER_CONFIG "$SERVER_NAME" 2> /dev/null || fail "Could not copy skeleton server configuration"

			# Change to new server
			access_server "$SERVER_NAME"

			# If JAR file was not specified, let the user select one iteractively
			if [ -z "$JAR_FILE" ]; then
				setjar
			# Or  use it
			else
				setjar "$JAR_FILE"
			fi

			# Create basic minecraft-specific files
			touch server.properties ops.txt white-list.txt 2> /dev/null || err "Could not create basic config files"

			# Create named pipes for the server
			mk_fifos
		fi
	# If no name was specified, we cannot create a server
	else
		fail "No server name specified"
	fi		
}

# Remove a server
remove() {
	# As default, ask again, before removing the server
	local FORCE=false

	# Switch options
	while (( $# ));do
		case $1 in
			--force)	FORCE=true
			;;
			*)		error "Unknown parameter '$1'"
		esac
		shift
	done

	# Do we really want to remove the server?
	local REMOVE=false

	# Check if we want to remove non-interactively
	if ( $FORCE ); then
		REMOVE=true
	else
		# Ask the user if they really wants to remove the server
		ask "Do you really want to remove the server '$SERVER_NAME'?" && REMOVE=true
	fi

	# If we finally want to remove the server
	if ( $REMOVE ); then
		# Change to server's directory
		access_server "$SERVER_NAME"

		# Stop server if it is running
		if ( service status > /dev/null 2> /dev/null ); then
			echo "Stopping running server..."
			service stop > /dev/null 2> /dev/null 
		fi

		# Change to parent folder
		cd .. 2> /dev/null || fail "Cannot change to parent directory"

		# Remove stuff
		rm -R "$SERVER_NAME" && succ "Server \"$SERVER_NAME\" removed" || fail "Failed to remove server\"$SERVER_NAME\""
	fi
}

# List available servers
list() {
	# Define tamporary server list	
	local SERVER_LIST="`mktemp`"

	# Don't be verbose by default
	local VERBOSE=false
	local VERY_VERBOSE=false

	# List all folders (servers) in the servers directory
	cd "$SERVERS_DIR" 2> /dev/null && ls_dir 2> /dev/null > $SERVER_LIST

	# Switch options
	while (( $# ));do
		case $1 in
			--verbose|-v)		VERBOSE=true
			;;
			--very-verbose|-vv)	VERBOSE=true
						VERY_VERBOSE=true
			;;
			*)			error "Unknown parameter '$1'"
		esac
		shift
	done

	# Iterate over all servers in the list
	while read SERVER_NAME; do
		# Print the server's name
		# Bold if verbose
		$VERBOSE && echo -en "\033[1m"
		echo -en "$SERVER_NAME"
		$VERBOSE && echo -e "\033[0m" || echo ""

		# Print some more information in verbose mode
		if ( $VERBOSE ); then
			access_server "$SERVER_NAME"
			echo -e "	\033[1mCONFIGURATION:\033[0m"
			configure
			if ( $VERY_VERBOSE ); then
				echo -e "	\033[1mPROPERTIES:\033[0m"
				properties
			fi
		fi
	done < $SERVER_LIST
}

# Configure minecraft server installation and configuration
configure() {
	# Set temporary configuration file
	local TMP_SERVER_CONFIG="`mktemp`"

	# Print configuration of server, if no arguments are specified
	if [ $# -eq 0 ]; then
		# Delete comments and empty lines from config file
		grep -vE "^#|^$" $SERVER_CONFIG > $TMP_SERVER_CONFIG 2> /dev/null || fail "Configuration file is missing"

		# Print used JAR file	
		echo -e "	JAR_FILE=`readlink minecraft_server.jar 2> /dev/null`"

		# Print configuration file content
                # Check if variables have been altered
                # and highlight such
                if [ -n "$CHANGED_VARS" ]; then
                        while read LINE; do
                                for VAR in $CHANGED_VARS; do
                                        if [ -n "`echo $LINE | grep ^"$VAR="`" ]; then
                                                echo -e "	\033[1m$LINE\033[0m"
                                                continue
                                        fi

                                        echo -e "	$LINE"
                                done
                        done < $TMP_SERVER_CONFIG

			# Clear list of changed variables
			CHANGED_VARS=
                else
                        while read LINE; do
                                echo -e "	$LINE"
                        done < $TMP_SERVER_CONFIG
                fi
	else
		# Switch arguments and set variables
		while (( $# )); do
			# Put var to upper case
			declare -u VAR=$1

			# Add variable to altered variables
			CHANGED_VARS="$CHANGED_VARS $VAR"

			# Change variable
			set_var $VAR $2 $SERVER_CONFIG
			shift 2

		done

		# Print new configuration after modifications
		configure
	fi
}

# Configure a server's properties
properties() {
	# Set temporary properties file
	local TMP_SERVER_PROPERTIES="`mktemp`"

	# Print server properties, if no arguments are specified
	if [ $# -eq 0 ]; then
		# Delete comments and empty lines from config file
		grep -vE "^#|^$" $SERVER_PROPERTIES > $TMP_SERVER_PROPERTIES 2> /dev/null || fail "Properties file is missing"

		# Print properties file content
		# Check if variables have been altered
		# and highlight such
		if [ -n "$CHANGED_VARS" ]; then
			while read LINE; do
				for VAR in $CHANGED_VARS; do
					if [ -n "`echo $LINE | grep ^"$VAR="`" ]; then
						echo -e "	\033[1m$LINE\033[0m"
						continue
					fi
					
					echo -e "	$LINE"
				done
			done < $TMP_SERVER_PROPERTIES

			# Clear list of changed variables
			CHANGED_VARS=
		else
			while read LINE; do
				echo -e "	$LINE"
			done < $TMP_SERVER_PROPERTIES
		fi	
	else
		# Process variable / value pairs
		while (( $# ));do
			# Put var to lower case
			declare -l VAR=$1

			# Add variable to altered variables
			CHANGED_VARS="$CHANGED_VARS $VAR"

			# Change variable
			set_var $VAR "$2" $SERVER_PROPERTIES
			shift 2
		done

		# Print new properties after modifications
		properties
	fi
}
	
# Manage a server's users
passwd() {
	#################
	# Set variables #
	#################

	# Set temporary file
	local TMP="`mktemp`"

	# Usage information
	local USAGE="Usage: \033[1m`basename $0`\033[0m \033[3mserver_name\033[0m \033[1mpasswd\033[0m [\033[3mCOMMAND\033[0m \033[4muser_name\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1madd\033[0m, \033[1mwhitelist\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the white-list

	\033[1mremove\033[0m, \033[1mblacklist\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from white-list

	\033[1mop\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the ops list

	\033[1mdeop\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from the ops list

	\033[1mstatus\033[0m \033[3muser_name\033[0m
		List status of \033[3muser_name\033[0m

	\033[1mprint\033[0m, \033[1mlist\033[0m
		Print current status, white- and ops-list

	\033[1mlock\033[0m
		Lock server by putting it into online mode and enabling the white-list (recommended)

	\033[1munlock\033[0m
		Unlock server by putting it into offline mode an disabling the white-list (not recommended)

	\033[1mhelp\033[0m
		Print this information
"

	####################
	# Passwd functions #
	####################

	# Reload the whitelist
	whitelist_reload() {
		if ( service status > /dev/null 2> /dev/null ); then
                        srv_exec whitelist reload > /dev/null 2> /dev/null
                fi
	}

	# Check if we are given a valid user name
	valid_user() {
		# Fail if no user name has been given
		if [ -z "$1" ]; then
			fail "No user name given"
		fi
	}

	# Check whether a certain user is white-listed
	is_whitelisted() {
		valid_user "$1"
		if ( is_in "$1" "$WHITE_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1mwhitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		fi
	}

	# Check whether a certain user is an operator
	is_op() {
		valid_user "$1"
		if ( is_in "$1" "$OP_LIST" ); then
			succ "User \033[1m$1\033[0m is \033[1man operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Add a user to the white-list, iff he's not in it yet
	whitelist() {
		valid_user "$1"
		if ( ! is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( add_to "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed whitelisting $1\033[0m on server \033[1m$SERVER_NAME\033[0m'.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1malready\033[0m whitelisted on server \033[1m$SERVER_NAME\033[0m."
		fi
		
		whitelist_reload
	}

	# Remove user from the white list, iff he's in it
	remove() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			deop "$1" 2> /dev/null
			if ( remove_from "$1" "$WHITE_LIST" > /dev/null 2> /dev/null ); then
				succ "User \033[1m$1 removed\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed removing $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi

		whitelist_reload
	}

	# Add a user to the operators list
	op() {
		valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( ! is_op "$1" > /dev/null 2> /dev/null ); then		
				if ( add_to "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
					# Make the user an operator instantly iff the server is running
					if ( service status > /dev/null 2> /dev/null ); then
						srv_exec op "$1" > /dev/null 2> /dev/null
					fi

					succ "User \033[1m$1\033[0m is \033[1mnow an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
				else
					err "\033[1mFailed opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
				fi
			else
				err "User \033[1m$1\033[0m is \033[1malready an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Delete a user from the operators list
	deop() {
		valid_user "$1"
		if ( is_op "$1" > /dev/null 2> /dev/null ); then
			if ( remove_from "$1" "$OP_LIST" > /dev/null 2> /dev/null ); then
					# Deop the user iff the server is running
					if ( service status > /dev/null 2> /dev/null ); then
						srv_exec deop "$1" > /dev/null 2> /dev/null
					fi

				succ "User \033[1m$1\033[0m is \033[1mno longer an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				err "\033[1mFailed de-opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			err "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Print the status of a user
	status() {
		valid_user "$1"
		if ( is_whitelisted "$1" ); then	
			is_op "$1"
		fi
	}

	# Print the status of the whole server mode, white-list and ops-list configuration
	print() {
		# Determine mode
		echo -en "Server \033[1m$SERVER_NAME\033[0m is configured as "
		if [ "`grep "online-mode" "$SERVER_PROPERTIES" 2> /dev/null | cut -d "=" -f 2 2> /dev/null`" == "true" ]; then
			echo -en "\033[1monline\033[0m"
		else
			echo -en "\033[1moffline\033[0m"
		fi

		# Determine whether white-list is enabled
		echo -n ", its white-list is "
		if [ "`grep "white-list" "$SERVER_PROPERTIES" 2> /dev/null | cut -d "=" -f 2 2> /dev/null`" == "true" ]; then
			echo -e "\033[1menabled\033[0m."
		else
			echo -e "\033[1mdisabled\033[0m."
		fi	

		# Display users
		echo -e "\n\033[1mWhitelisted users:\033[0m"
		cat "$WHITE_LIST" 2> /dev/null
		echo -e "\n\033[1mOperators:\033[0m"
		cat "$OP_LIST" 2> /dev/null
		echo ""
	}

	# Lock the server by putting it into online mode and enabling the white-list
	lock() {
		remove_any_from "online-mode" "$SERVER_PROPERTIES" && remove_any_from "white-list" "$SERVER_PROPERTIES" && echo "online-mode=true" >> "$SERVER_PROPERTIES" && echo "white-list=true" >> "$SERVER_PROPERTIES" && succ "Server locked." || err "Server locking failed."
	}

	# Unlock the server by putting it into offline mode and disabling the white-list
	# XXX: This is not recommended. We anyway want to offer this feature for there 
	# might be user that want to run an open game server e.g. on networking parties
	unlock() {
		remove_any_from "online-mode" "$SERVER_PROPERTIES" && remove_any_from "white-list" "$SERVER_PROPERTIES" && echo "online-mode=false" >> "$SERVER_PROPERTIES" && echo "white-list=false" >> "$SERVER_PROPERTIES" && succ "Server unlocked." || err "Server unlocking failed." 
	}

	# Switch commands
	while (( $# )); do
		case "$1" in
			reload)			whitelist_reload
			;;
			add|whitelist)		whitelist $2
						shift
			;;
			remove|blacklist)	remove $2
						shift
			;;
			op)			op $2
						shift
			;;
			deop)			deop $2
						shift
			;;
			status)			status $2
						shift
			;;
			lock)			lock
			;;
			unlock)			unlock
			;;
			""|list|print)		print
			;;
			-h|--help|help)		echo -e "$USAGE" | /usr/bin/less -r
						exit 0
			;;
			*)			fail "Unknown argument '$1'. Try:\n\t\$ $0 $CMD --help"
		esac
		shift
	done
}

# Create a backup of the server
backup() {
	# Set current time and date as default backup name
	local BACKUP_NAME="$SERVER_NAME-`date +%Y.%m.%d-%H.%M`"
	local SECURE=false
	local FORCE=false
	local GRACE_TIME=10
	local MESSAGE="Server is being shut down for backup"

	local RETVAL=2
	local SERVER_RUNNING=false
	
	# Set parameters as backup name if specified
	
	while (( $# )); do
		case $1 in
			--secure|-s)		SECURE=true
						shift
			;;
			--force|-f)		FORCE=true
						shift
			;;
			--grace-time|-t)	GRACE_TIME=$2
						shift 2
			;;
			--message|-m)		MESSAGE=$2
						shift 2
			;;
			*)			BACKUP_NAME="$@"
						break
		esac
	done

	# Check if we want to do a secure
	# bakup of an offline server
	if ( $SECURE ); then
		shutdown "$MESSAGE" $GRACE_TIME $FORCE
	fi			

	# Create the backup as a gzip compressed tar archive, but with the custom *.mcb suffix 
	tar czf "$MC_HOME/backup/$BACKUP_NAME.mcb" * > /dev/null 2> /dev/null 

	# Check return value of tar
	RETVAL=$?
	# The secure backup worked fine, iff tar returns 0
	if ( $SECURE ); then 
		if [ $RETVAL -ne 0 ]; then
			fail "Secure backup failed: Backup file is inconsistent"
		fi
	# The backup worked fine, iff tar returns something smaller or equal 1
	else
		if [ $RETVAL -gt 1 ]; then
			fail "Could not create backup"
		fi
	fi

	# If we were in secure mode and the server was running
	# the user maybe wants to restart it now
	if ( $SECURE ); then
		restart $FORCE
	fi
}

# Restore the server
restore() {
	# Assume latest backup shall be restored
	local BACKUP_NAME="`ls -tl $MC_HOME/backup/$SERVER_NAME-* 2> /dev/null | head -n1 | awk '{print $9}'`"
	local BACKUP=""
	local SERVER_RUNNING=false

	# We don't want to clean the server directory by default
	local CLEAN=false
	local FORCE=false
	local GRACE_TIME=10
	local MESSAGE="Server is being shut down for restore"
	
	# Switch options
	while (( $# )); do
		case $1 in
			--clean|-c)		CLEAN=true
			;;
			--force|-f)		FORCE=true
			;;
			--grace-time|-t)	GRACE_TIME=$2
						shift
			;;
			--message|-m)		MESSAGE=$2
						shift
			;;
			*)			BACKUP_NAME="$@"
						break
		esac
     		shift
	done

	# Check whether the backup file is present...
	# ... as the file itself (full or relative file path)...
	if [ -f "$BACKUP_NAME" ]; then
		BACKUP="$BACKUP_NAME"
	# ... or as the file's name located in the backup folder ...
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME"
	# ... or finally as the file's name in the backup folder without the suffix specified.
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME.mcb" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME.mcb"
	# Fail otherwise
	else
		fail "Specified backup file could not be found"
	fi

	# Shut down the server if it is running
	if ( service status ); then
		shutdown "$MESSAGE" $GRACE_TIME $FORCE
	fi
			
	# Clean the server if wanted
	if ( $CLEAN ); then
		clean "$SERVER_NAME"
	fi

	# Perform restore
	tar xzf "$BACKUP" > /dev/null 2> /dev/null && return 0 || fail "Could not restore backup"

	# Restart the server if wanted
	restart $FORCE
}

# Reset the server
reset() {
	# As default we want to keep our configuration
	local KEEP_CONFIG=false
	local CFG_BACKUP="`mktemp`"
	local FORCE=false
	local GRACE_TIME=10
	local MESSAGE="Server is being shut down for reset"

	# Switch options
	while (( $# )); do
		case $1 in
			--erase-config|-ec|-e)	KEEP_CONFIG=false
			;;
			--force|-f)		FORCE=true
			;;
			--grace-time|-t)	GRACE_TIME=$2
						shift
			;;
			--message|-m)		MESSAGE=$2
						shift
			;;
			*)			error "Unrecognized argument '$1'"
		esac
		shift
	done

	# Server must be shut down
	shutdown "$MESSAGE" $GRACE_TIME $FORCE

	# If we want to keep the configuration, we create a temporal archive from them
	# XXX: Do not mix this up with our server's main backup() function
	if ( $KEEP_CONFIG ); then
		tar czf $CFG_BACKUP banned-ips.txt banned-players.txt ops.txt server.properties white-list.txt 2> /dev/null || fail "Saving of configuration failed"
	fi

	# Remember used jar file
	local JAR_FILE=`readlink minecraft_server.jar`
	
	# Clean up the server
	clean "$SERVER_NAME" || fail

	# Link back to the active minecraft_server.jar
	ln -s $JAR_FILE minecraft_server.jar || err "Resetting JAR file failed"
	
	# If we wanted to keep our configuration, we now restore its backup	
	if ( $KEEP_CONFIG ); then
		tell "Restoring configuration\t\t\t"
		tar xzf $CFG_BACKUP 2> /dev/null || fail "Could not restore configuration"
		rm $CFG_BACKUP 2> /dev/null
	fi
		
	# Restart the server if wanted
	restart $FORCE
}

# Check if updates for JAR files are available
check_update() {
	# Change to temoprary directory
	cd $TMP_DIR > /dev/null 2> /dev/null || fail "Could not change to temporary directory"

	# Update counter
	local UPDATES=0

	# Parse our repo list
	parse_repo

	# Iterate over each repository entry in the repository list
	while read REPO; do
		# Skip empty lines
		if [ -z "$REPO" ]; then
			continue
		fi

		# The URL to the jar file
		local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
		# A descriptive name of the JAR file
		local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
		# The name of the file we want to store
		local REPO_FILE=`basename $REPO_URL`

		# Make sure the repo file does not exist yet
		# TODO: This is no nice way to do that
		rm -f $REPO_FILE 2> /dev/null

		# Download the JAR file
		tell "Retrieving \"$REPO_NAME\"\t"
		wget -q "$REPO_URL" -O $REPO_FILE 2> /dev/null || fail
		
		# If the file exists...
		if [ -f $JAR_DIR/$REPO_FILE ]; then
			# ...and it is the same, we don't need to update it
			if ( cmp $JAR_DIR/$REPO_FILE $REPO_FILE > /dev/null 2> /dev/null ); then
				succ "[ up 2 date ]"
			else
				succ "[ outdated  ]"

				# Increment update counter
				UPDATES=$(($UPDATES+1))
			fi
		else
			succ "[ available ]"

			# Increment update counter
			UPDATES=$(($UPDATES+1))
		fi

	done < $TMP_REPO_LIST

	# Return value is number of updates
	return $UPDATES
}

# Update Minecraft's JAR files
update() {
	# Change to temoprary directory
	cd $TMP_DIR > /dev/null 2> /dev/null || fail "Could not change to temporary directory"

	# Indicator if something was updated
	local UPDATED=false

	# Parse our repo list
	parse_repo

	# Iterate over each repository entry in the repository list
	while read REPO; do
		# Skip empty lines
		if [ -z "$REPO" ]; then
			continue
		fi

		# The URL to the jar file
		local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
		# A descriptive name of the JAR file
		local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
		# The name of the file we want to store
		local REPO_FILE=`basename $REPO_URL`

		# Make sure the repo file does not exist yet
		# TODO: This is no nice way to do that
		rm -f $REPO_FILE 2> /dev/null

		# Download the JAR file
		tell "Retrieving \"$REPO_NAME\"\t"
		wget -q "$REPO_URL" -O $REPO_FILE 2> /dev/null || fail
		
		# If the file exists...
		if [ -f $JAR_DIR/$REPO_FILE ]; then
			# ...and it is the same, we don't need to update it
			if ( cmp $JAR_DIR/$REPO_FILE $REPO_FILE > /dev/null 2> /dev/null ); then
				succ "[ up 2 date ]"
				continue
			fi
		fi

		# Move the temporary file to it's targeted location
		mv $REPO_FILE $JAR_DIR/ 2> /dev/null && succ "[  updated  ]" || err

		# Mark that something has been updated
		UPDATED=true
	done < $TMP_REPO_LIST

	if ( $UPDATED ); then		
		# The servers using the updated JAR files should be restarted now
		echo -e "Updates have been installed\nAppropriate servers should be restarted"
	fi
}

# Manage the repository
repo() {
	# Usage information
	USAGE="Usage: \033[1m`basename $0`\033[0m \033[1mrepo\033[0m [\033[3mCOMMAND\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m
		List available repositories

	\033[1madd\033[0m \033[3mURL\033[0m \033[3mname\033[0m
		Add a repository

	\033[1mremove\033[0m \033[3mname\033[0m
		Remove a repository
"
	
	##################
	# Repo functions #
	##################

	# List available repositories
	ls_repo() {
		# Parse our repo list
		parse_repo

		echo -e "\nAvailable Repositories:\n\n│\t\t\033[1mName\033[0m\t\t│\t\t\t\t\033[1mURL\033[0m"

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# Skip empty lines
			if [ -z "$REPO" ]; then
				continue
			fi

			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The name of the file we want to store
			local REPO_FILE=`basename $REPO_URL`

			echo -e "├───────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────"
			echo -e "│\t$REPO_NAME\t│\t$REPO_URL"
		done < $TMP_REPO_LIST
		echo -e "└───────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────"
	}

	# Add an entry to the repository
	add_repo() {
		# Clear variables
		local REPO_URL="$1"
		local REPO_NAME="$2"

		# If nothing has been specified via the parameters, go to interactive mode
		if [ -z "$REPO_URL" ]; then
			echo -en "Please enter the repository's URL\nURL: "
			read REPO_URL
		fi

		if [ -z "$REPO_NAME" ]; then
			echo -en "Please enter the repository's name\nName: "
			read REPO_NAME
		fi

		# Store new repository in file
		echo "$REPO_URL#$REPO_NAME" >> $REPO_LIST 2> /dev/null || fail "New repository could not be saved"
	}

	# Remove an entry from the repository list
	rm_repo() {
		# Only argument: The Repo's name
		local REPO_NAME="$1"

		# If nothing has been specified via the parameters, go to interactive mode
		if [ -z "$REPO_NAME" ]; then
			tell "Please enter the repository's name\nName: "
			read REPO_NAME
		fi

		# Remove repo from the list if it is inside
		if [ -n "`grep "#$REPO_NAME"$ $REPO_LIST 2> /dev/null`" ]; then
			grep -v "#$REPO_NAME"$ $REPO_LIST > $REPO_LIST.tmp 2> /dev/null && mv $REPO_LIST.tmp $REPO_LIST 2> /dev/null || fail "Could not remove repository"
		else
			err "Specified repository is not in the reposotories' file"
		fi
	}

	CMD=$1
	shift
	
	# Switch commands
	case $CMD in
		""|list)		ls_repo "$@"
		;;
		add)			add_repo "$@"
		;;
		remove)			rm_repo "$@"
		;;
		--help|-h|help)		echo -e "$USAGE" | /usr/bin/less -r
					exit 0
		;;
		*)			error "Unknown command '$CMD'\nTry --help for help"
					exit 1
	esac
}

# List available JAR files
ls_jar() {
	# Change to the JARs' folder
	cd $JAR_DIR 2> /dev/null || fail "JAR file directory not found"

	# Parse arguments
	case $1 in
		-a|--all)	ls --color=auto -alF
		;;
		*)		ls --color=auto *.jar 2> /dev/null || fail "No jar files in the JARs' directory.\nTry\n\t$0 update"
	esac
}
	
# Set a new active JAR file
setjar() {
	# The second parameter is the JAR file
	local JAR_FILE_NAME=$1
	local JAR_FILE=""

	# Read JAR file interactively if not specified via a parameter
	if [ -z "$JAR_FILE_NAME" ]; then
		# Show available JAR files...
		if ( ls_jar ); then
			echo -en "Please specify the jar file that you want to use.\nJAR file: "
			read JAR_FILE_NAME
		# ...and exit if we don't have any
		else
			exit 1
		fi
	fi

	# Check if JAR file is present
	if [ -f $JAR_FILE_NAME ]; then
		JAR_FILE=$JAR_FILE_NAME
	elif [ -f $JAR_DIR/$JAR_FILE_NAME ]; then
		JAR_FILE=$JAR_DIR/$JAR_FILE_NAME
	elif [ -f $JAR_DIR/$JAR_FILE_NAME.jar ]; then
		JAR_FILE=$JAR_DIR/$JAR_FILE_NAME.jar
	else
		fail "Specified JAR file could not be found"		
	fi

	# Link to new JAR file
	unlink minecraft_server.jar 2> /dev/null; ln -sf $JAR_FILE minecraft_server.jar 2> /dev/null &&	echo "Server should be restarted" || fail "Could not set new JAR file"
}

#############################
# Minecraft server commands #
#############################

# Send commands to server and print results
srv_exec() {
	# Per default, we don't want to see the verbose output
	local VERBOSE=false
	local SHOW_TAIL=false
	local WAIT_TIME=0.1

	# Switch options
	while (( $# )); do
		case $1 in
			--verbose|-v)	VERBOSE=true
					shift
			;;
			--show-tail|-s)	SHOW_TAIL=true
					shift
			;;
			--wait-time|-w)	WAIT_TIME=$2
					shift 2
			;;
			*)		break
		esac
	done

	# Execute a raw query
	exec_cmd() {
		access_server "$SERVER_NAME"

		local CAT_PID=/tmp/minectl.cat.pid
		
		# Delete tail if unwanted
		if ( ! $SHOW_TAIL ); then
			# Open stderr fifo for reading and discard the output
			(	
				cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
			) > /dev/null 2> /dev/null
			# Wait a short time
			sleep $WAIT_TIME 2> /dev/null || err "Could not sleep"
			# Close the sterr fifo
			kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
			# Remove PID file
			rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
		fi

		# Open stderr fifo for reading
		(	
			cat stderr 2> /dev/null& echo $! > $CAT_PID 2> /dev/null
		) 2> /dev/null
		# Echo command into stdin fifo
		echo $@ > stdin 2> /dev/null || fail "Could not execute command \"$@\""
		# Wait a short time
		sleep $WAIT_TIME 2> /dev/null || err "Could not sleep"
		# Close the sterr fifo
		kill `cat $CAT_PID` 2> /dev/null || err "Could not kill cat"
		# Remove PID file
		rm -f $CAT_PID 2> /dev/null || err "Could not remove cat.pid"
	}

	if ( $VERBOSE ); then
		exec_cmd $@
	else 
		exec_cmd $@ | cut -d " " -f 4-
	fi
}

# List players that are logged in
# Return 0 iff there are players on the server
# or 1 else
list_players() {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1

	srv_exec list | tail -n +2 > $TMP_PLAYERS 2> /dev/null

	if [ -n "`cat $TMP_PLAYERS`" ]; then
		cat "$TMP_PLAYERS"
		RETVAL=0
	fi
	
	rm -f $TMP_PLAYERS 2> /dev/null 
	echo "There are no players on the server"
	return $RETVAL	
}

# Display count of players logged in
# Return 0 iff there are players on the server
# or 1 else
player_count()  {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1
	
	srv_exec list | head -n 1 | awk '{ print $3 }' | cut -d "/" -f 1 > $TMP_PLAYERS 2> /dev/null
	cat $TMP_PLAYERS
	PLAYERS=`cat $TMP_PLAYERS`

	if [ $PLAYERS -gt 0 ]; then
		RETVAL=0
	fi

	rm -f $TMP_PLAYERS 2> /dev/null
	return $RETVAL
}

##################################
# Init/Systemd control functions #
##################################

# Perform operations on minectl's system service
service() {
	# Usage information
        local USAGE="\033[1mUsage: `basename $0` <server_name> service <COMMAND> [COMMAND..]\033[0m

\033[1mCOMMANDS\033[0m
	\033[1enable\033[0m
                Enable the server on system startup

        \033[1mdisable\033[0m
                Disable the server on system startup

        \033[1mstart\033[0m
                Start the server

        \033[1mstop\033[0m
                Stop the server

        \033[1mstatus\033[0m
                Print status of the server

        \033[1mrestart\033[0m
                Restart the server

        \033[1mhelp\033[0m
                Print this information
"

	# Enable a server for startup
	enable() {
		if [ -f "/lib/systemd/system/minecraft@.service" ]; then
			runas root /usr/bin/systemctl enable minecraft@$SERVER_NAME.service
		else
			runas root /bin/echo "$SERVER_NAME" >> /etc/minectl.servers 2> /dev/null || fail "Could not enable server"
		fi
	}

	# Disable a server for starup
	disable() {
		if [ -f "/lib/systemd/system/minecraft@.service" ]; then
			runas root /usr/bin/systemctl disable minecraft@$SERVER_NAME.service
		else
			runas root /bin/sed -i "/$SERVER_NAME/d" /etc/minectl.servers 2> /dev/null || fail "Could not disable server"
		fi
	}

	# Perform an execution on the respective init script
	init() {
		if [ -f "/lib/systemd/system/minecraft@.service" ]; then
			runas root /usr/bin/systemctl $1 minecraft@$SERVER_NAME.service
		else
			runas root /etc/init.d/minecraft $1 "$SERVER_NAME" || fail "Could not $1 server $SERVER_NAME"
		fi
	}
	
	# Switch commands
	while (( $# )); do
		case $1 in
			enable)		enable
			;;
			disable)	disable
			;;
			start)		init start
			;;
			stop)		init stop
			;;
			restart)	init restart
			;;
			status)		init status
			;;
			--help|-h|help)	echo -e "$USAGE"
			;;
			*)		error "Unknown argument '$1'. Try:\n\t\$ $0 $CMD --help"
		esac
		shift
	done
}

######################################################################################################################

###############
# Main script #
###############

# Read command
CMD=$1
shift

# Check if we are a valid user
if [ "$USER" != "$MC_USER" -a $EUID -ne 0 ]; then
	fail "You need to be either $MC_USER or root to run this"
fi

# Switch commands and execute appropriate functions
case $CMD in
	init)			init "$@"
	;;
	list)			list "$@"
	;;
	add)			add "$@"
	;;
	check-update)		check_update "$@"
	;;
	update)			update "$@"
	;;
	repo)			repo "$@"
	;;
        lsjar)			ls_jar "$@"
	;;
	""|help|--help|-h)	case $1 in
					passwd)		passwd --help
					;;
					repo)		repo --help
					;;
					service)	service --help
					;;
					*)	echo -e "$USAGE" | /usr/bin/less -r
				esac
	;;
	--version)		echo -e "`basename $0`-$VERSION.$ARCH"
	;;
	*)			# If no commands match, we assume, that
				# the argument is the server's name
				SERVER_NAME=$CMD

				# Change securely to the server's directory
				access_server "$SERVER_NAME"

				# Switch commands on the servers
				CMD=$1
				shift

				case $CMD in

					remove)			remove "$@"
					;;
					passwd)			passwd "$@"
					;;
					configure|config|cfg)	configure "$@"
					;;
					properties|props|pro)	properties "$@"
					;;
					backup)			backup "$@"
					;;
					restore)		restore "$@"
					;;
					reset)			reset "$@"
					;;
					set-jar|jar)		setjar "$@"
					;;
					service)		service "$@"
					;;
					exec)			srv_exec "$@"
					;;
					players)		list_players "$@"
					;;
					player-count)		player_count "$@"
					;;
					"")			err "No command entered\nType\n\t$0 --help\nfor information about usage"
					;;
					# Assume that we want to run a command of the Java program
					# iff nothing else applies
					*)			srv_exec "$CMD" "$@"
				esac
esac

# Return the state of the last command
exit $?
