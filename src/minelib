#! /bin/bash
#
#	minelib - Library for functions frequently used by minectl's scripts
#
#	Version 1.0
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.

###########################
# Miscellaneous functions #
###########################

# Inform user about operations being executed
tell() {
        echo -en "$@"
}

# Echo state and indicate success
succ() {
        if [ -z "$1" ]; then
                echo -e "[   done    ]"
        else
                echo -e "$1"
        fi
        return 0
}

# Echo state and indicate an error
err() {
        if [ -z "$1" ]; then
                echo -e "[   error   ]" 1>&2
        else
                echo -e "$1" 1>&2
        fi
        return 1
}

# Print out an error message to stderr
error() {
	echo -e "ERROR: $@" 1>&2
	return 1
}

# Echo state and indicate faliure and exit
fail() {
        if [ -z "$1" ]; then
                echo -e "[  failed   ]" 1>&2
        else
                echo -e "$1" 1>&2
        fi
        exit 1
}

# Run command as different user
# Usage: runas <user_name> [COMMAND] [OPTIONS..]
runas() {
	if [ $# -lt 2 ]; then
		echo "Usage: runas <user_name> [COMMAND] [OPTIONS..]" 1>&2
		return 1
	fi

	TARGET_NAME="$1"
	shift

	ACTIVE_USER="`who am i | awk '{ print $1}'`"

	if [ "$TARGET_NAME" == "ACTIVE_USER" ]; then
		$@
	else
		# Test if user may run sudo
		sudo -u "$TARGET_NAME" /usr/bin/true 2> /dev/null
		if [ $? -eq 0 ]; then
			sudo -u "$TARGET_NAME" su - -c "$@"
		else
			su - -c "$@" "$TARGET_NAME"
		fi
	fi
	return $?
}

# Ask a question and return 0 on 'yes' or 1 otherwise
ask() {

	USAGE="\
	Usage: ask [The yes / no question]\nReturns 0 on \"y\" or 1 on \"n\" where \"n\" is default."

	if [ $# -lt 1 ]; then
		echo -e $USAGE
		return 2
	fi

	echo -n "$@ [y/N]: " 
	read ANSWER
	shopt -s nocasematch
	case "$ANSWER" in
		j|y|ja|yes)
			return 0;;
		*)	return 1;;
	esac
	shopt -u nocasematch
}

# Change the value of an existing variable inside a file
set_var() {
	# Clear the value of a variable
	clear_var() {
		VARIABLE="$1"
		FILE="$2"
		
		# Redirect to 'alter_var'
		alter_var "$VARIABLE" "" "$FILE"
	}

	# Remove a variable entry from the appropriate config file
	remove_var() {
		VARIABLE="$1"
		FILE="$2"
		TMP_CONFIG_FILE=$TMP_DIR/tmp-config-file.cfg

		# Remove the variable using 'grep -v' on the config file and writing it back
		grep -v ^"$VARIABLE=" "$FILE" > "$TMP_CONFIG_FILE" 2> /dev/null
		mv "$TMP_CONFIG_FILE" "$FILE" 2> /dev/null
	}
		

	# Change the value of a variable
	alter_var() {
		VARIABLE="$1"
		VALUE="$2"
		FILE="$3"

		# Search for variable inside the file	
		VAR_LINE="`grep ^"$VARIABLE=" "$FILE" 2> /dev/null`"

		# If the variable is in the file, replace it with its new value
		if [ -n "$VAR_LINE" ]; then
			sed -i "s/$VAR_LINE/$VARIABLE=$VALUE/" "$FILE" 2> /dev/null
		else
			echo "$VARIABLE=$VALUE" >> "$FILE"
		fi
	}

	# If first argument is like 'remove', then the variable shall be cleared
	shopt -s nocasematch
	case $1 in
		--clear|--unset)	clear_var "$2" "$3"
		;;
		--remove|--delete)	remove_var "$2" "$3"
		;;
		*)			alter_var "$1" "$2" "$3"
		;;
	esac
	shopt -u nocasematch
}

# List (just) directories in the current folder (without sub directories)
ls_dir() {
	find ./ -type d 2> /dev/null | grep -E ^"./.[^/]*"$ | sed 's:./::g'
}

# Add a string to a file
add_to() {
	echo "$1" >> "$2"
	return $?
}

# Check whether a string is in the beginning of a file's line
is_in() {
	grep -i ^"$1"$ "$2" > /dev/null 2> /dev/null
	return $?
}

# Remove a string that is in the beginning of a file from this file
remove_from() {
	grep -vi ^"$1"$ "$2" > "$TMP"
	mv "$TMP" "$2"
}

# Remove any occurance of a string from a file
remove_any_from() {
	grep -vi "$1" "$2" > "$TMP"
	mv "$TMP" "$2"
}

################################
# Minecraft-specific functions #
################################

# Access a server's directory securely
# XXX: Do not just use a simple "cd" statement to change to a server's directory, beacuase
# if a user does not specify a server name by mistake, we will change to $MC_HOME/servers 
# and, if clean is called "clean()", may remove all servers by mistake. That won't be good!
# 'access_server' also makes sure that a certain server (directory) exists
access_server() {
	# First parameter is the server name
	SERVER_NAME=$1
	
	# Check is server name is not empty
	test -n "$SERVER_NAME" 2> /dev/null || fail "No server name specified."

	# Check whether server's directory is accessible
	test -d "$SERVERS_DIR/$SERVER_NAME" 2> /dev/null || fail "Server '$SERVER_NAME' does not exist"

	# Check whether server's directory is accessible
	cd "$SERVERS_DIR/$SERVER_NAME" 2> /dev/null || fail "Cannot access_server server's directory"

	# Check if we did really change to a subfolder of $MC_HOME/servers
	test "`dirname $PWD`" == "$SERVERS_DIR" 2> /dev/null || fail "We are somehow in the '$SERVERS_DIR' directory"
}

###################################
# Import error codes and messages #
###################################
# TODO: Implement later
#. `dirname $0`/errcodes || err "Error codes could not be loaded from `dirname $0`/errcodes"
