#! /bin/bash
#
#	minectl - Control a minecraft server
#
#	Copyright (C) 2012 Richard Neumann <mail@richard-neumann.de>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# TODO: Make all output language-dependent
# TODO: Outsource common functions to minelib

#######################
# Version information #
#######################

VERSION=6.0
ARCH=noarch

####################
# Global variables #
####################

# Synopsis of usage for user information
USAGE="Usage:	\033[1m`basename $0`\033[0m [\033[1mINDEPENDENT_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m \033[3mSERVER_NAME\033[0m [\033[1mSERVER_SPECIFIC_COMMAND\033[0m]

   or:	\033[1m`basename $0`\033[0m [\033[1mMETA_COMMAND\033[0m]

\033[1mINDEPENDENT COMMANDS\033[0m
	\033[1minit\033[0m
		Initialize the server manager.

	\033[1mlist\033[0m, \033[1mls\033[0m [\033[1m--verbose\033[0m, \033[1m--very-verbose\033[0m]
		List available servers.

	\033[1madd\033[0m \033[3mserver_name\033[0m [\033[1m--jar\033[0m \033[3mjar_file\033[0m]
		Add a new server. 
		You can specify a jar file to be used or select it interactively.

	\033[1mjar\033[0m [\033[1mREPO_COMMAND\033[0m]
		Manage the JAR files and repository.
		See \033[1m`basename $0` jar --help\033[0m for further information.

\033[1mSERVER SPECIFIC COMMANDS\033[0m
	\033[1mremove\033[0m [\033[1m--force\033[0m]
		Entirely remove a server from the disk.
		You can avoid querying by using the \033[1m--force\033[0m switch.

	\033[1mrename\033[0m \033[3mnew_name\033[0m
		Rename a server.

	\033[1m\033[3mServer configuration\033[0m
		\033[1mpasswd\033[0m [\033[1mPASSWD_COMMAND\033[0m \033[3muser_name\033[0m]
			Manage the server's users.
			See \033[1m`basename $0` --help passwd\033[0m for further information.

		\033[1mconfigure\033[0m, \033[1mconfig\033[0m or \033[1mcfg\033[0m
			Show the server's meta-configuration.
		\033[1mconfigure\033[0m [\033[3mvariable\033[0m=\033[4mvalue\033[0m]
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's meta-configuration file.
		\033[1mconfigure\033[0m [-\033[3mvariable\033[0m]
			Delete \033[3mvariable\033[0m from the server's meta-configuration file.

		\033[1mproperties\033[0m, \033[1mprops\033[0m or \033[1mpro\033[0m
			Show the appropriate server.properties data.
		\033[1mproperties\033[0m [\033[3mvariable\033[0m=\033[4mvalue\033[0m]
			Set \033[3mvariable\033[0m to \033[4mvalue\033[0m in the server's server.properties file.
		\033[1mproperties\033[0m [-\033[3mvariable\033[0m]
			Delete \033[3mvariable\033[0m from the server's server.properties file.

	\033[1m\033[3mBackup, Restore and Reset\033[0m
		For \033[1mbackup\033[0m, \033[1mrestore\033[0m and \033[1mreset\033[0m you can use the
			following common options:
			\033[1m--force\033[0m
				To activate non-interactive mode in operations.
			\033[1m--grace-time\033[0m \033[3mgrace_time\033[0m
				To set the grace time in seconds for when the 
				appropriate server will be shut down (default: 10).
			\033[1m--message\033[0m \033[3mmessage\033[0m
				To specify the message send to users on the server.

		\033[1mbackup\033[0m [\033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Create a backup of the server.
			You can specify the name of the backup to be saved.

		\033[1mrestore\033[0m [\033[1m--clean\033[0m, \033[1mCOMMON_OPTIONS\033[0m] [\033[1mbackup_name\033[0m]\033[0m
			Restore latest backup of the server.
			You can specify the name of the backup to be restored in \033[3mbackup_name\033[0m 
			instead of restoring the latest one.
			To erase the server's data before restoring (to minelib_clean it up) use the 
			\033[1m--clean\033[0m switch, which must be the first argument.

		\033[1mreset\033[0m [\033[1m--erase-config\033[0m, \033[1mCOMMON_OPTIONS\033[0m]\033[0m
			Reset the server to its initial state.
			Use the \033[1m--erase-config\033[0m switch to also erase the server's configuration.

	\033[1m\033[3mInit / Systemd service control\033[0m
		\033[1mstatus\033[0m
		        Check if the server is running

	\033[1m\033[3mJava program commands\033[0m
		\033[1mexec\033[0m [\033[1mARGS\033[0m] \033[3mMINECRAFT_SERVER_COMMAND\033[0m
			Send commands to the server's stdin and print out replies
			Possible arguments are:
			\033[1m--verbose\033[0m, \033[1m-v\033[0m
				Show verbose output.
			\033[1m--show-tail\033[0m, \033[1m-s\033[0m
				Show the tail of the pipe and
				not only the command's results.
			\033[1m--no-clean\033[0m, \033[1m-n\033[0m
				Do not minelib_clean up the input and 
				output queue before executing a
				command.
			\033[1m--wait-time\033[0m, \033[1m-w\033[0m \033[3mseconds\033[0m
				Specify waiting time in seconds
				to wait for the pipe to close again.

		\033[1mplayers\033[0m
		        List players logged in to the server
	
		\033[1mplayer-count\033[0m
		        List count of players logged in to the server.

		\033[3mMINECRAFT_SERVER_COMMAND\033[0m [\033[3mARGS\033[0m]
		        If none of the aforementioned commands apply, minectl will
		        interpret the command as command for the minecraft 
			server's Java program.

\033[1mMETA COMMANDS\033[0m
	\033[1m--help\033[0m
		Print this infomation

	\033[1m--version\033[0m     		
		Print version information and exit
"

######################################################################################################################

###########################
# Miscellaneous functions #
###########################

# Indicate failure when loading of shared library fails
minectl_lib_fail() {
	echo "Could not load main library" 1>&2
	exit 1
}

#######################
# Source main library #
#######################
source /usr/local/libexec/minectl/minelib 2> /dev/null || minectl_lib_fail

###################################
# Import messages and minelib_err or codes #
###################################
source $LIB_DIR/lang/default.lang 2> /dev/null || minelib_fail "Language files could not be loaded from `dirname $0`/default.lang"
source $LIB_DIR/errcodes 2> /dev/null || minelib_fail "minelib_err or codes could not be loaded from `dirname $0`/minelib_err codes"

######################################################################################################################

##################
# Main functions #
##################

# Initialize the minecraft server installation and configuration after installation
# This should be done interactively
minectl_init() {
	# Change to home directory
	cd $MC_HOME 2> /dev/null || minelib_fail ACCESS_HOME_DIR_FAILED

	# Check if no servers are configured yet
	if ( ! minectl_list_servers ); then
		minelib_prompt srv_name
		read SERVER_NAME

		# Check if we already have some JAR files at hand (although this should not be the case)
		if ( minectl_jar list ); then
			# minelib_ask the user which jar file shall be used
			minelib_prompt SELECT_JAR_FILE
			read JAR_FILE
		else
			# minelib_ask the user to update the system
			if ( minelib_ask jar_update ); then
				minectl_jar update
				minectl_jar upgrade
				minectl_jar list
				minelib_prompt SELECT_JAR_FILE
				read JAR_FILE
			else
				minelib_notify UPDATE_MANUALLY
				exit 1
			fi
		fi

		# Add the new server
		minectl_add_server "$SERVER_NAME" --jar "$JAR_FILE" 

	# If we already have servers, don't initialize
	else
		minelib_notify INIT_NOT_REQUIRED
	fi		
}

# Add a server
minectl_add_server() {
	# First parameter is the server name
	local SERVER_NAME=$1
	shift

	# JAR file to be used
	local JAR_FILE=

	# Switch options
	while (( $# )); do
		case $1 in
			--jar)	JAR_FILE=$2
				shift
			;;
			*)	minelib_err UNKNOWN_PARAM $1
		esac
		shift
	done

	# Change to servers directory
	cd $SERVERS_DIR 2> /dev/null || minelib_fail ACCESS_SRV_DIR_FAILED

	# Check if we specified a server name
	if [ -n "$SERVER_NAME" ]; then
		# Check whether no such file or folder already exists
		if [ -e "$SERVER_NAME" ]; then
			# If there's already such a directory, we assume that the server already exists
			if [ -d "$SERVER_NAME" ]; then
				minelib_fail SRV_EXISTS
			# If the thing with the server's name is not a directory, we give up :-(
			else
				minelib_fail FILE_EXISTS
			fi				
		else
			# Create the server
			mkdir "$SERVER_NAME" 2> /dev/null || minelib_fail CREATE_SRV_DIR_FAILED
			cp "$SERVER_CONFIG" "$SERVER_NAME" 2> /dev/null || minelib_fail COPY_SKEL_CFG_FAILED

			# Change to new server
			minelib_access_server "$SERVER_NAME"

			# If JAR file was not specified, let the user select one iteractively
			if [ -z "$JAR_FILE" ]; then
				if ( jar list ); then
					minelib_prompt SELECT_JAR_FILE
					read JAR_FILE
				# ...and exit if we don't have any
				else
					exit 1
				fi
			fi

			minectl_server_configure "JAR_FILE=$JAR_FILE"

			# Create basic minecraft-specific files
			touch $SERVER_PROPERTIES $SERVER_OP_LIST $SERVER_WHITE_LIST $SERVER_LOG_FILE $SERVER_EVENT_HANDLERS_DIR 2> /dev/null || minelib_fail CREATE_CFG_FILES_FAILED

			# Create named pipes for the server
			minelib_mk_fifos 
		fi
	# If no name was specified, we cannot create a server
	else
		minelib_fail NO_SRV_NAME
	fi		
}

# Remove a server
minectl_server_remove() {
	# As default, minelib_ask again, before removing the server
	local FORCE=false

	# Switch options
	while (( $# ));do
		case $1 in
			--force)	FORCE=true
			;;
			*)		minelib_err  UNKNOWN_PARAM $1
		esac
		shift
	done

	# Do we really want to remove the server?
	local REMOVE=false

	# Check if we want to remove non-interactively
	if ( $FORCE ); then
		REMOVE=true
	else
		# minelib_ask the user if they really wants to remove the server
		minelib_ask REMOVE_SRV && REMOVE=true
	fi

	# If we finally want to remove the server
	if ( $REMOVE ); then
		# Change to server's directory
		minelib_access_server "$SERVER_NAME"

		# Stop server if it is running
		minectl_server_status > /dev/null 2> /dev/null && minelib_fail SRV_RUNNING

		# Change to parent folder
		cd .. 2> /dev/null || minelib_fail ACCESS_PARENT_DIR_FAILED

		# Remove stuff
		rm -R "$SERVER_NAME" && minelib_notify SRV_REMOVED || minelib_fail SRV_REMOVE_FAILED
	fi
}

# List available servers
minectl_list_servers() {
	# Define tamporary server list	
	local SERVER_LIST="`mktemp`"
	local RETVAL=1

	# Don't be verbose by default
	local VERBOSE=false
	local VERY_VERBOSE=false

	# List all folders (servers) in the servers directory
	cd "$SERVERS_DIR" 2> /dev/null && minelib_ls_dir 2> /dev/null > "$SERVER_LIST"

	# Switch options
	while (( $# ));do
		case $1 in
			--verbose|-v)		VERBOSE=true
			;;
			--very-verbose|-vv)	VERBOSE=true
						VERY_VERBOSE=true
			;;
			*)			minelib_err  UNKNOWN_PARAM  $1
		esac
		shift
	done

	# Iterate over all servers in the list
	while read SERVER_NAME; do
		# We obviously do have servers
		RETVAL=0

		# Print the server's name
		# Bold if verbose
		$VERBOSE && echo -en "\033[1m"
		echo -en "$SERVER_NAME"
		$VERBOSE && echo -e "\033[0m" || echo ""

		# Print some more information in verbose mode
		if ( $VERBOSE ); then
			minelib_access_server "$SERVER_NAME"
			echo -e " \033[1mCONFIGURATION:\033[0m"
			minectl_server_configure
			if ( $VERY_VERBOSE ); then
				echo -e " \033[1mPROPERTIES:\033[0m"
				minectl_server_properties
			fi
		fi
	done < "$SERVER_LIST"

	return $RETVAL
}

# Rename a server
minectl_server_rename() {
	local NEW_NAME="$@"

	if ( srv_status > /dev/null 2>/dev/null ); then
		minelib_fail SRV_RUNNING
	else
		cd ..
		mv "$SERVER_NAME" "$NEW_NAME" 2> /dev/null || minelib_fail SRV_RENAME_FAILED
	fi
}

# Configure minecraft server installation and configuration
minectl_server_configure() {
	minectl_server_configure_print() {		
		# Set temporary configuration file
		local TMP_SERVER_CONFIG="`mktemp`"

		# Delete comments and empty lines from config file
		minelib_extract_data $SERVER_CONFIG > $TMP_SERVER_CONFIG 2> /dev/null

		# Print used JAR file
		if ( minelib_fileop -b contains "JAR_FILE=" "$1" > /dev/null 2> /dev/null); then
			echo -en "\033[1m"
		fi
		echo -e " JAR_FILE=`readlink minecraft_server.jar 2> /dev/null`\033[0m"

		# Print configuration file content
                minelib_print_file -o " " "$TMP_SERVER_CONFIG" "$1"

		# Remove temp file
		rm -f $TMP_SERVER_CONFIG 2> /dev/null
	}
	
	# Set a new active JAR file
	minectl_server_configure_set_jar() {
		# The second parameter is the JAR file
		local JAR_FILE_NAME=$1
		local JAR_FILE=""

		# Read JAR file interactively if not specified via a parameter
		if [ -z "$JAR_FILE_NAME" ]; then
			minelib_fail NO_JAR_SPEC
		fi

		# Check if JAR file is present
		if [ -f $JAR_FILE_NAME ]; then
			JAR_FILE=$JAR_FILE_NAME
		elif [ -f $JAR_DIR/$JAR_FILE_NAME ]; then
			JAR_FILE=$JAR_DIR/$JAR_FILE_NAME
		elif [ -f $JAR_DIR/$JAR_FILE_NAME.jar ]; then
			JAR_FILE=$JAR_DIR/$JAR_FILE_NAME.jar
		else
			minelib_fail JAR_FILE_NOT_FOUND
		fi

		# Link to new JAR file
		unlink minecraft_server.jar 2> /dev/null; ln -sf $JAR_FILE minecraft_server.jar 2> /dev/null &&	minelib_notify SRV_RESTART || minelib_fail SET_JAR_FAILED
	}

	# Print configuration of server, if no arguments are specified
	if [ $# -eq 0 ]; then
		minectl_server_configure_print
	else
		local ALTERED_VARS="`mktemp`"

		while (( $# )); do
			local VARIABLE="$1"
			shift

			local -u VAR_NAME="`echo "$VARIABLE" | cut -d "=" -f 1`"
			local VAR_VAL="`echo "$VARIABLE" | cut -d "=" -f 2-`"

			# Check if we want to change the JAR file
			if [ "$VAR_NAME" == "JAR_FILE" ]; then
				minectl_server_configure_set_jar "$VAR_VAL"
				echo "JAR_FILE=$VAR_VAL" >> "$ALTERED_VARS"
			else
				# Change variable
				minelib_set_var -u "$VARIABLE" "$SERVER_CONFIG" >> "$ALTERED_VARS"
			fi
		done

		# Print new configuration after modifications
		minectl_server_configure_print "$ALTERED_VARS"

		rm -f "$ALTERED_VARS" 2> /dev/null
	fi
}

# Configure a server's properties
minectl_server_properties() {
	minectl_server_properties_print() {		
		# Set temporary properties file
		local TMP_SERVER_PROPERTIES="`mktemp`"

		# Delete comments and empty lines from config file
		minelib_extract_data $SERVER_PROPERTIES > $TMP_SERVER_PROPERTIES 2> /dev/null

		# Print properties file content
                minelib_print_file -o " " "$TMP_SERVER_PROPERTIES" "$1"

		# Remove temp file
		rm -f $TMP_SERVER_PROPERTIES 2> /dev/null
	}

	if [ $# -eq 0 ]; then
		minectl_server_properties_print
	else
		local ALTERED_VARS="`mktemp`"

		while (( $# )); do
			local VARIABLE="$1"
			shift

			# Change variable and			
			# mark it as altered
			minelib_set_var -l "$VARIABLE" "$SERVER_PROPERTIES" >> "$ALTERED_VARS"
		done

		# Print new properties after modifications
		minectl_server_properties_print "$ALTERED_VARS"
		rm -f "$ALTERED_VARS" 2> /dev/null
	fi
}
	
# Manage a server's users
minectl_server_passwd() {
	#################
	# Set variables #
	#################

	# Set temporary file
	local TMP="`mktemp`"

	# Usage information
	local USAGE="Usage: \033[1m`basename $0`\033[0m \033[3mserver_name\033[0m \033[1mpasswd\033[0m [\033[3mCOMMAND\033[0m \033[4muser_name\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1madd\033[0m, \033[1mwhitelist\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the white-list

	\033[1mremove\033[0m, \033[1mblacklist\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from white-list

	\033[1mop\033[0m \033[3muser_name\033[0m
		Add \033[3muser_name\033[0m to the ops list

	\033[1mdeop\033[0m \033[3muser_name\033[0m
		Remove \033[3muser_name\033[0m from the ops list

	\033[1mstatus\033[0m \033[3muser_name\033[0m
		List status of \033[3muser_name\033[0m

	\033[1mprint\033[0m, \033[1mlist\033[0m
		Print current status, white- and ops-list

	\033[1mlock\033[0m
		Lock server by putting it into online mode and enabling the white-list (recommended)

	\033[1munlock\033[0m
		Unlock server by putting it into offline mode an disabling the white-list (not recommended)

	\033[1mhelp\033[0m
		Print this information
"

	####################
	# Passwd functions #
	####################

	# Reload the whitelist
	minectl_server_passwd_whitelist_reload() {
		minectl_server_execute whitelist reload > /dev/null 2> /dev/null
	}

	# Check if we are given a valid user name
	minectl_server_passwd_valid_user() {
		# minelib_fail if no user name has been given
		if [ -z "$1" ]; then
			minelib_fail no_user_name
		fi
	}

	# Check whether a certain user is white-listed
	minectl_server_passwd_is_whitelisted() {
		minectl_server_passwd_valid_user "$1"
		if ( minelib_fileop -f -i contains "$1" "$SERVER_WHITE_LIST" ); then
			minelib_notify "User \033[1m$1\033[0m is \033[1mwhitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m"
		fi
	}

	# Check whether a certain user is an operator
	minectl_server_passwd_is_op() {
		minectl_server_passwd_valid_user "$1"
		if ( minelib_fileop -f -i contains "$1" "$SERVER_OP_LIST" ); then
			minelib_notify "User \033[1m$1\033[0m is \033[1man operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Add a user to the white-list, iff he's not in it yet
	minectl_server_passwd_whitelist() {
		minectl_server_passwd_valid_user "$1"
		if ( ! minectl_server_passwd_is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( minelib_fileop add "$1" "$SERVER_WHITE_LIST" > /dev/null 2> /dev/null ); then
				minelib_notify "User \033[1m$1 whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				minelib_err  "\033[1mFailed whitelisting $1\033[0m on server \033[1m$SERVER_NAME\033[0m'.\nCheck your configuration."
			fi
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1malready\033[0m whitelisted on server \033[1m$SERVER_NAME\033[0m."
		fi
		
		minectl_server_passwd_whitelist_reload
	}

	# Remove user from the white list, iff he's in it
	minectl_server_passwd_remove() {
		minectl_server_passwd_valid_user "$1"
		if ( is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			minectl_server_passwd_deop "$1" 2> /dev/null
			if ( minelib_fileop -f -i remove "$1" "$SERVER_WHITE_LIST" > /dev/null 2> /dev/null ); then
				minelib_notify "User \033[1m$1 removed\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				minelib_err  "\033[1mFailed removing $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi

		minectl_server_passwd_whitelist_reload
	}

	# Add a user to the operators list
	minectl_server_passwd_op() {
		minectl_server_passwd_valid_user "$1"
		if ( minectl_server_passwd_is_whitelisted "$1" > /dev/null 2> /dev/null ); then
			if ( ! minectl_server_passwd_is_op "$1" > /dev/null 2> /dev/null ); then		
				if ( minelib_fileop add "$1" "$SERVER_OP_LIST" > /dev/null 2> /dev/null ); then
					# Make the user an operator instantly 
					# on the running server
					minectl_server_execute op "$1" > /dev/null 2> /dev/null

					minelib_notify "User \033[1m$1\033[0m is \033[1mnow an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
				else
					minelib_err  "\033[1mFailed opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
				fi
			else
				minelib_err  "User \033[1m$1\033[0m is \033[1malready an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			fi
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1mnot whitelisted\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Delete a user from the operators list
	minectl_server_passwd_deop() {
		minectl_server_passwd_valid_user "$1"
		if ( minectl_server_passwd_is_op "$1" > /dev/null 2> /dev/null ); then
			if ( minelib_fileop -f -i remove "$1" "$SERVER_OP_LIST" > /dev/null 2> /dev/null ); then
				# Deop the user on running server
				minectl_server_execute deop "$1" > /dev/null 2> /dev/null

				minelib_notify "User \033[1m$1\033[0m is \033[1mno longer an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
			else
				minelib_err  "\033[1mFailed de-opping $1\033[0m on server \033[1m$SERVER_NAME\033[0m.\nCheck your configuration."
			fi
		else
			minelib_err  "User \033[1m$1\033[0m is \033[1mnot an operator\033[0m on server \033[1m$SERVER_NAME\033[0m."
		fi
	}

	# Print the status of a user
	minectl_server_passwd_status() {
		minectl_server_passwd_valid_user "$1"
		if ( minectl_server_passwd_is_whitelisted "$1" ); then	
			is_op "$1"
		fi
	}

	# Print the status of the whole server mode, white-list and ops-list configuration
	minectl_server_passwd_print() {
		# Determine mode
		echo -en "Server \033[1m$SERVER_NAME\033[0m is configured as "
		if ( minelib_fileop -f -i contains "online-mode=true" "$SERVER_PROPERTIES" > /dev/null 2> /dev/null ); then
			echo -en "\033[1monline\033[0m"
		else
			echo -en "\033[1moffline\033[0m"
		fi

		# Determine whether white-list is enabled
		echo -n ", its white-list is "
		if ( minelib_fileop -f -i contains "white-list=true" "$SERVER_PROPERTIES" > /dev/null 2> /dev/null ); then
			echo -e "\033[1menabled\033[0m."
		else
			echo -e "\033[1mdisabled\033[0m."
		fi	

		# Display users
		echo -e "\n\033[1mWhitelisted users:\033[0m"
		cat "$SERVER_WHITE_LIST" 2> /dev/null
		echo -e "\n\033[1mOperators:\033[0m"
		cat "$SERVER_OP_LIST" 2> /dev/null
		echo ""
	}

	# Lock the server by putting it into online mode and enabling the white-list
	minectl_server_passwd_lock() {
		minectl_server_properties "online-mode=true" "white-list=true" > /dev/null && minelib_notify SRV_LOCKED || minelib_fail SRV_LOCKING_FAILED
	}

	# Unlock the server by putting it into offline mode and disabling the white-list
	# XXX: This is not recommended. We anyway want to offer this feature for there 
	# might be user that want to run an open game server e.g. on networking parties
	minectl_server_passwd_unlock() {
		minectl_server_properties "online-mode=false" "white-list=false" > /dev/null && minelib_notify SRV_UNLOCKED || minelib_fail SRV_UNLOCKING_FAILED
	}

	# Switch commands
	while (( $# )); do
		case "$1" in
			reload)			minectl_server_passwd_whitelist_reload
			;;
			add|whitelist)		minectl_server_passwd_whitelist $2
						shift
			;;
			remove|blacklist)	minectl_server_passwd_remove $2
						shift
			;;
			op)			minectl_server_passwd_op $2
						shift
			;;
			deop)			minectl_server_passwd_deop $2
						shift
			;;
			status)			minectl_server_passwd_status $2
						shift
			;;
			lock)			minectl_server_passwd_lock
			;;
			unlock)			minectl_server_passwd_unlock
			;;
			""|list|print)		minectl_server_passwd_print
			;;
			-h|--help|help)		echo -e "$USAGE" | /usr/bin/less -r
						exit 0
			;;
			*)			minelib_fail UNKNOWN_PARAM $1
		esac
		shift
	done
}

# Create a backup of the server
minectl_server_backup() {
	# Set current time and date as default backup name
	local BACKUP_NAME="$SERVER_NAME-`date +%Y.%m.%d-%H.%M`"
	local MESSAGE_PRE=
	local MESSAGE_POST=

	# Process params
	while (( $# )); do
		case $1 in
			--message-pre|--message|-m)	MESSAGE_PRE="$2"
							shift 2
			;;
			--message-post|-p)		MESSAGE_POST="$2"
							shift 2
			;;
			*)				break
		esac
	done
		
	# If there is still an argument (or more) remaining
	# it must be the backup's name
	if [ $# -gt 0 ]; then
		BACKUP_NAME="$@"
	fi

	# Display pre-backup message on server
	if [ -n "$MESSAGE_PRE" ]; then
		minectl_server_execute say "$MESSAGE_PRE"
	fi
	
	# Create the backup as a gzip compressed tar archive, but with the custom *.mcb suffix 
	tar czf "$MC_HOME/backup/$BACKUP_NAME.mcb" * > /dev/null 2> /dev/null 
	if [ $? -le 1 ]; then		
		# Display pre-backup message on server
		if [ -n "$MESSAGE_POST" ]; then
			minectl_server_execute say "$MESSAGE_POST"
		fi

		return 0
	else
		# Display failure message on server, if one type of
		# notification was enabled.
		if [ -n "$MESSAGE_PRE" -o -n "$MESSAGE_POST" ]; then
			minectl_server_execute say "WARNING: Attempted backup failed!"
		fi

		minelib_fail BACKUP_FAILED
	fi
}

# Restore the server
minectl_server_restore() {
	# Assume latest backup shall be restored
	local BACKUP_NAME="`ls -tl $MC_HOME/backup/$SERVER_NAME-* 2> /dev/null | head -n1 | awk '{print $9}'`"
	local BACKUP=""

	# We don't want to minelib_clean the server directory by default
	local CLEAN=false
	
	# Switch options
	while (( $# )); do
		case $1 in
			--clean|-c)		CLEAN=true
			;;
			*)			BACKUP_NAME="$@"
						break
		esac
     		shift
	done

	# Check whether the backup file is present...
	# ... as the file itself (full or relative file path)...
	if [ -f "$BACKUP_NAME" ]; then
		BACKUP="$BACKUP_NAME"
	# ... or as the file's name located in the backup folder ...
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME"
	# ... or finally as the file's name in the backup folder without the suffix specified.
	elif [ -f "$MC_HOME/backup/$BACKUP_NAME.mcb" ]; then
		BACKUP="$MC_HOME/backup/$BACKUP_NAME.mcb"
	# minelib_fail otherwise
	else
		minelib_fail BACKUP_NOT_FOUND
	fi

	# Check if server is still running
	minectl_server_status > /dev/null 2> /dev/null && minelib_fail SRV_RUNNING
			
	# Clean the server if wanted
	if ( $CLEAN ); then
		minelib_clean "$SERVER_NAME"
	fi

	# Perform restore
	tar xzf "$BACKUP" > /dev/null 2> /dev/null && return 0 || minelib_fail RESTORE_FAILED
}

# Reset the server
minectl_server_reset() {
	# As default we want to keep our configuration
	local KEEP_CONFIG=false

	# Switch options
	while (( $# )); do
		case $1 in
			--erase-config|-ec|-e)	KEEP_CONFIG=false
			;;
			*)			minelib_err  UNKNOWN_PARAM $1
		esac
		shift
	done

	# Check if server is still running
	minectl_server_status > /dev/null 2> /dev/null && minelib_fail SRV_RUNNING

	# If we want to keep the configuration, we create a temporal archive from them
	# XXX: Do not mix this up with our server's main backup() function
	if ( $KEEP_CONFIG ); then
		tar czf $CFG_BACKUP banned-ips.txt banned-players.txt ops.txt server.properties white-list.txt 2> /dev/null || minelib_fail CONFIG_BACKUP_FAILED
	fi

	# Remember used jar file
	local JAR_FILE=`readlink minecraft_server.jar`
	
	# Clean up the server
	minelib_clean "$SERVER_NAME" || minelib_fail

	# Link back to the active minecraft_server.jar
	ln -s $JAR_FILE minecraft_server.jar || minelib_err RESET_JAR_FAILED
	
	# If we wanted to keep our configuration, we now restore its backup	
	if ( $KEEP_CONFIG ); then
		tar xzf $CFG_BACKUP 2> /dev/null || minelib_fail RESTORE_CONFIG_FAILED
		rm $CFG_BACKUP 2> /dev/null
	fi
}

# Manage the JAR files
minectl_jar() {
	# Define repository list
	local REPO_LIST="$LIB_DIR/.repolist"

	# Set temporary repository for re-formatted repo list
	local TMP_REPO_LIST="`mktemp`"

	# Usage information
	local USAGE="Usage: \033[1m`basename $0`\033[0m \033[1mjar\033[0m [\033[3mCOMMAND\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m or \033[1mls\033[0m [\033[1m--all\033[0m]
		List available JAR files
 
	\033[1mupdate\033[0m [\033[3mREPOSITORY\033[0m]
		Update JAR file repository
 
	\033[1mupgrade\033[0m [\033[3mREPOSITORY\033[0m]
		Upgrade used JAR files to the latest ones

	\033[1mrepository\033[0m or \033[1mrepo\033[0m
		Perform operations on the repositories
		See \033[1m`basename $0` jar repository --help\033[0m for further information.

	\033[1m--help\033[0m, \033[1m-h\033[0m or \033[1mhelp\033[0m
		Print this information
"
	
	##################
	# Repo functions #
	##################

	# Parse the repository list
	minectl_jar_parse_repository() {
		# Check whether the repository list exists
		test -f "$REPO_LIST" 2> /dev/null || minelib_fail CHECK_REPO_FAILED

		# Re-format repo file
		minelib_extract_data "$REPO_LIST" > "$TMP_REPO_LIST" 2> /dev/null || minelib_fail PARSING_REPO_FAILED
	}

	# Operate on the repository
	minectl_jar_repository() {
		# Usage information
		local USAGE="Usage: \033[1m`basename $0`\033[0m \033[1mjar\033[0m \033[1mrepository\033[0m [\033[3mCOMMAND\033[0m]

\033[1mCOMMANDS\033[0m
	\033[1mlist\033[0m or \033[1mls\033[0m [\033[1m--verbose\033[0m]
		List active repositories

	\033[1madd\033[0m \033[3mURL\033[0m \033[3mname\033[0m
		Add a repository

	\033[1mremove\033[0m, \033[1mrm\033[0m or \033[1mdelete\033[0m \033[3mname\033[0m
		Remove a repository

	\033[1m--help\033[0m, \033[1m-h\033[0m or \033[1mhelp\033[0m
		Print this information
"
		# List available repositories
		minectl_jar_repository_list() {
			# Parse our repo list
			minectl_jar_parse_repository

			# Switch for verbose output
			VERBOSE=false

			while (( $# )); do
				case $1 in
					--verbose|-v)	VERBOSE=true
					;;
				esac
				shift
			done

			echo -e "\033[2mAvailable Repositories:\033[0m\n"

			# Iterate over each repository entry in the repository list
			while read REPO; do
				# The URL to the jar file
				local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
				# A descriptive name of the JAR file
				local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
				# The name of the file we want to store
				local REPO_FILE="$JAR_DIR/$REPO_NAME.jar"

				echo -e "\033[1m$REPO_NAME\033[0m"
				if ( $VERBOSE ); then
					echo -e "\033[2mURL:\033[0m\t$REPO_URL"
					echo -e "\033[2mFILE:\033[0m\t$REPO_FILE\n"
				fi
			done < $TMP_REPO_LIST
		}

		# Add an entry to the repository
		minectl_jar_repository_add() {
			# Clear variables
			local REPO_URL="$1"
			local REPO_NAME="$2"

			# If nothing has been specified via the parameters, go to interactive mode
			if [ -z "$REPO_URL" ]; then
				minelib_prompt SPEC_REPO_URL
				read REPO_URL
			fi

			if [ -z "$REPO_NAME" ]; then
				minelib_prompt SPEC_REPO_NAME
				read REPO_NAME
			fi

			# Store new repository in file
			echo "$REPO_URL#$REPO_NAME" >> $REPO_LIST 2> /dev/null || minelib_fail REPO_SAVE_FAILED
		}

		# Remove an entry from the repository list
		minectl_jar_repository_remove() {
			# Only argument: The Repo's name
			local REPO_NAME="$1"

			# If nothing has been specified via the parameters, go to interactive mode
			if [ -z "$REPO_NAME" ]; then
				minelib_prompt SPEC_REPO_NAME
				read REPO_NAME
			fi

			# Remove repo from the list if it is inside
			minelib_fileop -e remove  "#$REPO_NAME" "$REPO_LIST" 2> /dev/null
			
		}

		local CMD=$1
		shift
	
		# Switch commands
		case $CMD in
			list|ls)		minectl_jar_repository_list "$@"
			;;
			add)			minectl_jar_repository_add "$@"
			;;
			remove|delete|rm)	minectl_jar_repository_remove "$@"
			;;
			--help|-h|help)		echo -e "$USAGE" | /usr/bin/less -r
						exit 0
			;;
			*)			minelib_fail UNKNOWN_PARAM $CMD
		esac
	}

	# List available JAR files
	minectl_jar_list() {
		# Change to the JARs' folder
		cd $JAR_DIR 2> /dev/null || minelib_fail ACCESS_JAR_DIR_FAILED

		# Parse arguments
		case $1 in
			-a|--all)	ls --color=auto -alF
			;;
			*)		if ( ! ls --color=auto *.jar 2> /dev/null ); then
						minelib_notify NO_JAR_FILES
						return 1
					fi
		esac
	}

	# Check if updates for JAR files are available
	minectl_jar_update() {
		# Change to temoprary directory
		cd "$JAR_REPO" > /dev/null 2> /dev/null || minelib_fail ACCESS_REPO_DIR_FAILED

		# Update counter
		local UPDATES=0

		# Skipping indicator
		local CONTINUE=false

		# Parse our repo list
		minectl_jar_parse_repository

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The name of the file we want to store
			local REPO_FILE="$JAR_REPO/`date +%s`-$REPO_NAME.jar"
			# The latest file of the repo
			local LATEST_FILE="$JAR_REPO/$REPO_NAME.latest.jar"

			# Check if we specified aonly a selection 
			# of repos and skip unwanted ones
			for WANTED_REPO in "$@"; do
				CONTINUE=true

				if [ "$REPO_NAME" == "$WANTED_REPO" ]; then
					CONTINUE=false
					break
				fi		
			done

			$CONTINUE && continue

			# Download the JAR file
			minelib_prompt  "Retrieving \033[1m$REPO_NAME\033[0m\t"
			wget -q "$REPO_URL" -O "$REPO_FILE" 2> /dev/null || minelib_fail "[  failed   ]"
		
			# If the file exists...
			if [ -f "$LATEST_FILE" ]; then
				# ...and it is the same, we don't need to update it
				if ( cmp "$LATEST_FILE" "$REPO_FILE" > /dev/null 2> /dev/null ); then
					rm -f "$REPO_FILE" 2> /dev/null
					minelib_notify "[ up 2 date ]"
					continue
				fi
			fi

			ln -sf "$REPO_FILE" "$LATEST_FILE" 2> /dev/null

			# Increment update counter
			UPDATES=$(($UPDATES+1))

			minelib_notify "[  updated  ]"
		done < $TMP_REPO_LIST

		# Return value is number of updates
		return $UPDATES
	}

	# Upgrade Minecraft's JAR files
	minectl_jar_upgrade() {
		# Change to temoprary directory
		cd "$JAR_REPO" > /dev/null 2> /dev/null || minelib_fail ACCESS_REPO_DIR_FAILED

		# Upgrade counter
		local UPGRADES=0

		# Skipping indicator
		local CONTINUE=false

		# Parse our repo list
		minectl_jar_parse_repository

		# Iterate over each repository entry in the repository list
		while read REPO; do
			# The URL to the jar file
			local REPO_URL="`echo "$REPO" | cut -d "#" -f 1`"
			# A descriptive name of the JAR file
			local REPO_NAME="`echo "$REPO" | cut -d "#" -f 2`"
			# The latest file of the repo
			local LATEST_FILE="$JAR_REPO/$REPO_NAME.latest.jar"
			# The current file of the repo
			local CURRENT_FILE="$JAR_DIR/$REPO_NAME.jar"
			# Check if we specified aonly a selection 
			# of repos and skip unwanted ones

			for WANTED_REPO in "$@"; do
				CONTINUE=true

				if [ "$REPO_NAME" == "$WANTED_REPO" ]; then
					CONTINUE=false
					break
				fi		
			done

			$CONTINUE && continue
		
			minelib_prompt  "JAR file from repo \033[1m$REPO_NAME\033[0m "
			# If the file exists...
			if [ -f "$LATEST_FILE" ]; then
				if [ -f "$CURRENT_FILE" ]; then
					# ...and it is the same, we don't need to update it
					if ( cmp "$CURRENT_FILE" "$LATEST_FILE" > /dev/null 2> /dev/null ); then
						echo "is up to date"
						continue
					fi
				fi

				ln -sf "`readlink $LATEST_FILE`" "$CURRENT_FILE" 2> /dev/null

				# Increment update counter
				UPGRADES=$(($UPGRADES+1))

				minelib_notify "has been upgraded"
			else
				minelib_notify JAR_UPDATE
				exit 1
			fi
		done < $TMP_REPO_LIST

		# Return value is number of updates
		return $UPDATES
	}


	local CMD=$1
	shift
	
	# Switch commands
	case $CMD in
		list|ls)		minectl_jar_list "$@"
		;;
		update)			minectl_jar_update "$@"
		;;
		upgrade)		minectl_jar_upgrade "$@"
		;;
		repository|repo)	minectl_jar_repository "$@"
		;;
		--help|-h|help)		echo -e "$USAGE" | /usr/bin/less -r
					exit 0
		;;
		*)			minelib_err  UNKNOWN_PARAM $1
					exit 1
	esac
}

#############################
# Minecraft server commands #
#############################

# Send commands to server and print results
minectl_server_execute() {
	# Per default, we don't want to see the verbose output
	local VERBOSE=false
	local SHOW_TAIL=false
	local WAIT_TIME=0.1
	local CLEAN=true

	# Switch options
	while (( $# )); do
		case $1 in
			--verbose|-v)	VERBOSE=true
					shift
			;;
			--show-tail|-s)	SHOW_TAIL=true
					shift
			;;
			--wait-time|-w)	WAIT_TIME=$2
					shift 2
			;;
			--no-clean|-n)	CLEAN=false
					shift 2
			;;
			*)		break
		esac
	done

	# Execute a Java command on the server
	minectl_server_execute_cmd() {
		minelib_access_server "$SERVER_NAME"

		if ( minectl_server_status > /dev/null 2> /dev/null ); then
			# Push command into server's stdin pipe
			echo $@ > $SERVER_STDIN 2> /dev/null || minelib_fail EXEC_CMD_FAILED
		else
			minelib_fail SRV_NOT_RUNNING
		fi
	}

	# If cleaning is enabled, perform an empty query first
	if ( $CLEAN ); then
		# If SHOW_TAIL is enabled, print the recent output
		if ( $SHOW_TAIL ); then
			minectl_server_execute_cmd " "
		# Else, discard the output
		else
			minectl_server_execute_cmd " " 2> /dev/null
		fi
	fi

	# If verbose information is wanted, also
	# do not cut off timestamps and info fields
	if ( $VERBOSE ); then
		minectl_server_execute_cmd $@
	else 
		minectl_server_execute_cmd $@ | cut -d " " -f 4-
	fi
}

# List players that are logged in
# Return 0 iff there are players on the server
# or 1 else
minectl_server_players() {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1

	minectl_server_execute list | tail -n +2 > $TMP_PLAYERS 2> /dev/null

	if [ -n "`cat $TMP_PLAYERS`" ]; then
		cat "$TMP_PLAYERS"
		RETVAL=0
	else
		minelib_notify NO_PLAYERS
	fi
	
	rm -f $TMP_PLAYERS 2> /dev/null 
	return $RETVAL	
}

# Display count of players logged in
# Return 0 iff there are players on the server
# or 1 else
minectl_server_player_count()  {
	local TMP_PLAYERS="`mktemp`"
	local RETVAL=1
	
	minectl_server_players | head -n 1 | awk '{ print $3 }' | cut -d "/" -f 1 > $TMP_PLAYERS 2> /dev/null
	cat $TMP_PLAYERS
	PLAYERS=`cat $TMP_PLAYERS`

	if [ $PLAYERS -gt 0 ]; then
		RETVAL=0
	fi

	rm -f $TMP_PLAYERS 2> /dev/null
	return $RETVAL
}

##################################
# Init/Systemd control functions #
##################################

# Determine status of server
minectl_server_status() {
	if [ -f "/lib/systemd/system/minecraft@.service" ]; then
		/usr/bin/systemctl status minecraft@$SERVER_NAME.service
	elif [ -f "/etc/init.d/minecraft" ]; then
		/etc/init.d/minecraft status "$SERVER_NAME" 
	else
		minelib_fail DETERMINE_STATUS_FAILED
	fi
}

##################
# Event handling #
##################

# Handle event configuration
minectl_server_event() {
	# List events enabled for the current server
	minectl_server_event_list() {
		case $1 in
			--all)	cd "$EVENT_HANDLERS_DIR"
			;;
			*)	cd "$SERVER_EVENT_HANDLERS_DIR"
		esac

		ls *.eh 2> /dev/null
	}

	# Add an event to the server
	minectl_server_event_add() {
		EVENT_NAME="$1.eh"

		if [ -f "$EVENT_HANDLERS_DIR/$EVENT_NAME" ]; then
			ln -s "$EVENT_HANDLERS_DIR/$EVENT_NAME" "$SERVER_EVENT_HANDLERS_DIR/$EVENT_NAME" 2> /dev/null
		else
			minelib_fail NO_SUCH_EVENT $1
		fi
	}

	# Add an event to the server
	minectl_server_event_remove() {
		EVENT_NAME="$1.eh"

		if [ -f "$SERVER_EVENT_HANDLERS_DIR/$EVENT_NAME" ]; then
			unlink "$SERVER_EVENT_HANDLERS_DIR/$EVENT_NAME" 2> /dev/null
		else
			minelib_fail NO_SUCH_EVENT $1
		fi
	}

	local CMD="$1"
	shift

	case $CMD in
		ls|list)	minectl_server_event_list "$@"
		;;
		add)		minectl_server_event_add "$@"
		;;
		remove|rm)	minectl_server_event_remove "$@"
		;;
		*)		minelib_err UNKNOWN_PARAM $1
	esac		
}

######################################################################################################################

###############
# Main script #
###############

# Read command
CMD=$1
shift

# Check if we are a valid user
if [ "$USER" != "$MC_USER" ]; then
	minelib_fail "You need to be $MC_USER to run this"
fi

# Switch commands and execute appropriate functions
case $CMD in
	init)			minectl_init "$@"
	;;
	list|ls)		minectl_list_servers "$@"
	;;
	add)			minectl_add_server "$@"
	;;
        jar)			minectl_jar "$@"
	;;
        events)			minectl_server_event list --all
	;;
	""|help|--help|-h)	case $1 in
					passwd)		minectl_server_passwd --help
					;;
					jar)		minectl_jar --help
					;;
					*)	echo -e "$USAGE" | /usr/bin/less -r
				esac
	;;
	--version)		echo -e "`basename $0`-$VERSION.$ARCH"
	;;
	*)			# If no commands match, we assume, that
				# the argument is the server's name
				SERVER_NAME=$CMD

				# Change securely to the server's directory
				minelib_access_server "$SERVER_NAME"

				# Switch commands on the servers
				CMD=$1
				shift

				case $CMD in
					remove)			minectl_server_remove "$@"
					;;
					rename)			minectl_server_rename "$@"
					;;
					passwd)			minectl_server_passwd "$@"
					;;
					configure|config|cfg)	minectl_server_configure "$@"
					;;
					properties|props|pro)	minectl_server_properties "$@"
					;;
					backup)			minectl_server_backup "$@"
					;;
					restore)		minectl_server_restore "$@"
					;;
					reset)			minectl_server_reset "$@"
					;;
					event)			minectl_server_event "$@"
					;;
					status)			minectl_server_status "$@"
					;;
					exec)			minectl_server_execute "$@"
					;;
					players)		minectl_server_players "$@"
					;;
					player-count)		minectl_server_player_count "$@"
					;;
					""|help|--help|-h)	echo -e "$USAGE" | /usr/bin/less -r
					;;
					# Assume that we want to run a command of the Java program
					# iff nothing else applies
					*)			echo "Executing '$CMD $@' on server '$SERVER_NAME'"
								minectl_server_execute "$CMD" "$@"
				esac
esac

# Return the state of the last command
exit $?
